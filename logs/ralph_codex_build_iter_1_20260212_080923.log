OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/tolu/Desktop/dev/rn-bottom-sheet
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c529d-4161-74f1-a73f-43334759090d
--------
user
# Ralph Build Mode

Based on Geoffrey Huntley's Ralph Wiggum methodology.

---

## Phase 0: Orient

Read `.specify/memory/constitution.md` to understand project principles and constraints.

---

## Phase 1: Discover Work Items

Search for incomplete work from these sources (in order):

1. **specs/ folder** — Look for `.md` files NOT marked `## Status: COMPLETE`
2. **IMPLEMENTATION_PLAN.md** — If exists, find unchecked `- [ ]` tasks
3. **GitHub Issues** — Check for open issues (if this is a GitHub repo)
4. **Any task tracker** — Jira, Linear, etc. if configured

Pick the **HIGHEST PRIORITY** incomplete item:
- Lower numbers = higher priority (001 before 010)
- `[HIGH]` before `[MEDIUM]` before `[LOW]`
- Bugs/blockers before features

Before implementing, search the codebase to verify it's not already done.

---

## Phase 1b: Re-Verification Mode (No Incomplete Work Found)

**If ALL specs appear complete**, don't just exit — do a quality check:

1. **Randomly pick** one completed spec from `specs/`
2. **Strictly re-verify** ALL its acceptance criteria:
   - Run the actual tests mentioned in the spec
   - Manually verify each criterion is truly met
   - Check edge cases
   - Look for regressions
3. **If any criterion fails**: Unmark the spec as complete and fix it
4. **If all pass**: Output `<promise>DONE</promise>` to confirm quality

This ensures the codebase stays healthy even when "nothing to do."

---

## Phase 2: Implement

Implement the selected spec/task completely:
- Follow the spec's requirements exactly
- Write clean, maintainable code
- Add tests as needed

---

## Phase 3: Validate

Run the project's test suite and verify:
- All tests pass
- No lint errors
- The spec's acceptance criteria are 100% met

---

## Phase 3b: Conditional Maestro MCP E2E Gate (Example App)

Identify the active feature spec and check its E2E gate marker:
- Look for `E2E Gate State: deferred|required` in `specs/<feature>/spec.md`.
- Default to `deferred` if the marker is missing.

Gate behavior:
- If `deferred`: do NOT block this loop iteration. Log that Maestro MCP was skipped and why.
- If `required`: Maestro MCP is a hard gate for completion.

When `required`, run Maestro MCP against the example app and verify at least:
- sheet opens from example UI
- sheet dismisses cleanly
- detent interaction works
- primary in-sheet navigation flow works

If any required Maestro MCP flow fails, do NOT output `<promise>DONE</promise>`.

---

## Phase 4: Commit & Update

1. Mark the spec/task as complete (add `## Status: COMPLETE` to spec file)
2. `git add -A`
3. `git commit` with a descriptive message
4. `git push`

---

## Completion Signal

**CRITICAL:** Only output the magic phrase when the work is 100% complete.

Check:
- [ ] Implementation matches all requirements
- [ ] All tests pass
- [ ] All acceptance criteria verified
- [ ] Maestro MCP gate satisfied (or explicitly deferred in the active spec)
- [ ] Changes committed and pushed
- [ ] Spec marked as complete

**If ALL checks pass, output:** `<promise>DONE</promise>`

**If ANY check fails:** Fix the issue and try again. Do NOT output the magic phrase.

mcp: maestro starting
mcp: codex_apps starting
mcp: context7 starting
mcp: codex_apps ready
mcp: maestro ready
mcp: context7 ready
mcp startup: ready: codex_apps, maestro, context7

thinking
**Outlining autonomous workflow approach**
codex
I’m going to run the Ralph build loop end-to-end: first I’ll read the project constitution and Ralph skill instructions, then discover the highest-priority incomplete work item and verify it isn’t already implemented before making changes.
exec
/bin/zsh -lc "sed -n '1,260p' '/Users/tolu/.agents/skills/ralph-wiggum/SKILL.md'" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "pwd && ls -la && test -f .specify/memory/constitution.md && sed -n '1,240p' .specify/memory/constitution.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
---
name: ralph-wiggum
description: Autonomous AI coding with spec-driven development. Implements Geoffrey Huntley's iterative bash loop methodology where agents work through specs one at a time, outputting a completion signal only when acceptance criteria are 100% met.
license: MIT
metadata:
  author: fstandhartinger
  version: "1.0"
  repository: https://github.com/fstandhartinger/ralph-wiggum
  website: https://ralph-wiggum.ai
---

# Ralph Wiggum

> Autonomous AI coding with spec-driven development

## What is Ralph Wiggum?

Ralph Wiggum combines **Geoffrey Huntley's iterative bash loop** with **spec-driven development** for fully autonomous AI-assisted software development.

The key insight: **Fresh context each iteration**. Each loop starts a new agent process with a clean context window, preventing context overflow and degradation.
 succeeded in 51ms:
/Users/tolu/desktop/dev/rn-bottom-sheet
total 1184
drwxr-xr-x   46 tolu  staff    1472 Feb 12 02:30 .
drwxr-xr-x@ 108 tolu  staff    3456 Feb 12 02:05 ..
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .claude
drwxr-xr-x    3 tolu  staff      96 Feb 12 02:11 .codex
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .cursor
-rw-r--r--@   1 tolu  staff     283 Feb 12 00:45 .editorconfig
drwxr-xr-x@  14 tolu  staff     448 Feb 12 08:09 .git
-rw-r--r--@   1 tolu  staff      72 Feb 12 00:45 .gitattributes
drwxr-xr-x@   5 tolu  staff     160 Feb 12 00:45 .github
-rw-r--r--@   1 tolu  staff     866 Feb 12 01:45 .gitignore
-rw-r--r--@   1 tolu  staff       9 Feb 12 00:45 .nvmrc
drwxr-xr-x@   5 tolu  staff     160 Feb 12 02:02 .specify
-rw-r--r--@   1 tolu  staff       2 Feb 12 00:45 .watchmanconfig
drwxr-xr-x@   4 tolu  staff     128 Feb 12 02:26 .yarn
-rw-r--r--@   1 tolu  staff      96 Feb 12 00:45 .yarnrc.yml
-rw-------@   1 tolu  staff     756 Feb 12 02:13 AGENTS.md
-rw-r--r--@   1 tolu  staff     119 Feb 12 01:44 CLAUDE.md
-rw-r--r--@   1 tolu  staff    5489 Feb 12 00:45 CODE_OF_CONDUCT.md

thinking
**Planning tasks and verification**
codex
I’ve loaded both the constitution and the Ralph skill guidance. Next I’m auditing `specs/`, `IMPLEMENTATION_PLAN.md`, and repo metadata to identify the single highest-priority incomplete item and confirm whether it’s already implemented.
exec
/bin/zsh -lc "if [ -f IMPLEMENTATION_PLAN.md ]; then sed -n '1,260p' IMPLEMENTATION_PLAN.md; fi" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg --files specs -g '*.md' | sort" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'git remote -v && git status --short --branch' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# Implementation Plan

> Auto-generated breakdown of specs into tasks.
> Delete this file to return to working directly from specs.

## Priority Tasks

### Phase 1: API and Nitro Contract

- [x] [HIGH] Define complete TypeScript type model (BottomSheetDetent, BottomSheetChangeReason) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with full public props interface - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with public methods (present, dismiss, snapToDetent, getCurrentDetentIndex) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Define callback prop types (onOpenChange, onDetentChange, lifecycle callbacks) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Regenerate Nitrogen artifacts after contract changes - from tasks/todo.md Phase 1
- [x] [HIGH] Validate typings compile and exports work correctly - from tasks/todo.md Phase 1
- [x] [HIGH] Update src/index.tsx to export all public types - from IMPLEMENTATION_PLAN API Design

### Phase 2: iOS Sheet Engine

- [x] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
 succeeded in 52ms:
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md
specs/001-native-ios-sheet-bindings/checklists/requirements.md
specs/001-native-ios-sheet-bindings/data-model.md
specs/001-native-ios-sheet-bindings/plan.md
specs/001-native-ios-sheet-bindings/quickstart.md
specs/001-native-ios-sheet-bindings/research.md
specs/001-native-ios-sheet-bindings/spec.md
specs/001-native-ios-sheet-bindings/tasks.md
 succeeded in 51ms:
origin	https://github.com/tolulawson/rn-bottom-sheet.git (fetch)
origin	https://github.com/tolulawson/rn-bottom-sheet.git (push)
## main...origin/main
 M .specify/templates/plan-template.md
 M .specify/templates/spec-template.md
 M PROMPT_build.md
 M PROMPT_plan.md
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
?? logs/
?? yarn.lock

thinking
**Prioritizing incomplete specs**
codex
I found several unchecked medium/low items in `IMPLEMENTATION_PLAN.md`, but I still need to resolve priority from `specs/` first per your rules. I’m now checking status markers and acceptance criteria in the spec files, plus existing `tasks/todo.md` so I can write/update the execution plan before coding.
exec
/bin/zsh -lc "if [ -f tasks/todo.md ]; then sed -n '1,260p' tasks/todo.md; else echo 'NO tasks/todo.md'; fi" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' specs/001-native-ios-sheet-bindings/spec.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'rg -n "''^## Status:|E2E Gate State|'"\\[ \\]\" specs/001-native-ios-sheet-bindings/*.md specs/001-native-ios-sheet-bindings/checklists/*.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# Feature Specification: Native iOS Sheet Bindings

**Feature Branch**: `001-native-ios-sheet-bindings`  
**Created**: 2026-02-12  
**Status**: Complete  
**Input**: User description: "Build a React Native library that provides native iOS sheet bindings using Nitro Views with React Native children, dynamic detents, React Navigation integration, in-sheet navigation, and Reanimated-compatible APIs."

## Status: COMPLETE

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Present Native Sheet Content (Priority: P1)

As a React Native developer, I can present and dismiss a native-feeling iOS sheet that renders arbitrary React Native child content so that product experiences match Apple sheet behavior.

**Why this priority**: This is the core product value and the minimum viable capability for the package.

**Independent Test**: In an example app, the developer can open/close a sheet and see custom React Native children rendered correctly without writing custom native code.

**Acceptance Scenarios**:
 succeeded in 52ms:
# Implementation Todo

## Phase 0: Project Memory Bootstrap

- [x] Create `docs/` knowledge base structure
- [x] Add decision-complete implementation plan
- [x] Add reference summaries and source index
- [x] Add ADRs for primary architecture decisions
- [x] Add sync/check scripts for docs integrity

## Phase 1: API and Nitro Contract

- [x] Finalize public TypeScript API and Nitro view contract
- [x] Regenerate Nitrogen artifacts
- [x] Validate typings and exports

## Phase 2: iOS Sheet Engine

- [ ] Implement presenter/controller architecture
- [ ] Map detent model and lifecycle events
 succeeded in 51ms:
specs/001-native-ios-sheet-bindings/spec.md:8:## Status: COMPLETE
specs/001-native-ios-sheet-bindings/spec.md:101:- **E2E Gate State**: `deferred`
specs/001-native-ios-sheet-bindings/spec.md:123:- **SC-006**: When `E2E Gate State` is `required`, Maestro MCP flows for the example app pass for open, dismiss, detent interaction, and in-sheet navigation in 100% of release-gate runs.
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:11:- [ ] CHK001 Are requirements defined for both controlled and imperative sheet control modes? [Completeness, Spec §FR-001, FR-002]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:12:- [ ] CHK002 Are requirements defined for rendering arbitrary child content and not only static content? [Completeness, Spec §FR-003]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:13:- [ ] CHK003 Are non-iOS fallback requirements explicitly documented? [Completeness, Spec §FR-013]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:14:- [ ] CHK004 Are example-app demonstration requirements defined for all major capabilities? [Completeness, Spec §FR-014]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:18:- [ ] CHK005 Is “native-feeling” behavior clarified through measurable or testable outcomes? [Clarity, Spec §SC-001, SC-003]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:19:- [ ] CHK006 Are detent validation rules specific enough to avoid interpretation drift? [Clarity, Spec §FR-004, FR-005]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:20:- [ ] CHK007 Is “deterministic behavior” defined in terms of explicit callback/state expectations? [Clarity, Spec §FR-006, FR-007, FR-009]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:24:- [ ] CHK008 Are lifecycle callback requirements consistent with sheet session state transitions? [Consistency, Spec §FR-006, Data Model alignment]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:25:- [ ] CHK009 Are integration requirements for navigation and animation consistent with declared v1 scope boundaries? [Consistency, Spec §FR-010, FR-012, Assumptions]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:26:- [ ] CHK010 Is single-session behavior consistent across functional requirements and edge-case descriptions? [Consistency, Spec §FR-009, Edge Cases]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:30:- [ ] CHK011 Are success criteria objectively measurable without implementation-specific tooling assumptions? [Measurability, Spec §SC-001..SC-005]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:31:- [ ] CHK012 Do acceptance scenarios cover open, dismiss, detent change, and integration paths for each user story? [Acceptance Criteria, Spec §User Scenarios]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:35:- [ ] CHK013 Are rapid state toggles and concurrent trigger scenarios explicitly addressed in requirements? [Coverage, Spec §Edge Cases]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:36:- [ ] CHK014 Are keyboard and content-resize edge cases represented as requirement-level behavior expectations? [Coverage, Edge Case, Spec §Edge Cases]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:37:- [ ] CHK015 Are invalid input/error scenarios mapped to explicit requirement obligations? [Coverage, Spec §FR-005]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:41:- [ ] CHK016 Are performance expectations for interaction smoothness and responsiveness specific and reviewable? [Non-Functional, Spec §Technical assumptions + SC-003]
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md:42:- [ ] CHK017 Are reliability expectations defined for lifecycle event ordering and no-crash fallback behavior? [Non-Functional, Spec §FR-013, SC-005]

thinking
**Planning deeper file inspection**
exec
/bin/zsh -lc 'tail -n 200 tasks/todo.md' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
- [x] Confirm `T001` is the highest-priority incomplete item and verify implementation state in code/docs
- [x] Mark `T001` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
- [x] Capture results in the Review section

## Ralph Iteration 2026-02-12 (Phase 1 Contract Pointer T002)

- [x] Confirm `T002` is the highest-priority truly incomplete task and verify `docs/knowledge-index.md` lacks a direct feature contract pointer
- [x] Add direct feature contract pointer in `docs/knowledge-index.md`
- [x] Mark `T002` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
- [x] Capture results in the Review section

## Ralph Iteration 2026-02-12 (US1 iOS Integration Flow Assertions T011)

- [x] Confirm `T011` is the highest-priority truly incomplete task and verify `T003` is already implemented (stale checkbox only)
- [x] Add iOS integration flow assertions in `example/src/__tests__/sheet-open-dismiss.integration.test.tsx`
- [x] Mark `T011` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
- [x] Capture results in the Review section

thinking
**Prioritizing incomplete implementation tasks**
codex
I confirmed the active feature spec itself is marked complete, so the next priority source is `IMPLEMENTATION_PLAN.md`, where the top unchecked item is `[MEDIUM] Implement grabberVisible prop mapping`. I’m now verifying whether that mapping already exists before touching code.
exec
/bin/zsh -lc "sed -n '1,320p' src/RnBottomSheet.nitro.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,320p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg -n \"grabberVisible|allowSwipeToDismiss|expandsWhenScrolledToEdge|cornerRadius|largestUndimmedDetent|backgroundInteraction|snapToDetent\\(\" ios src example | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
/**
 * Nitro View Contract for RnBottomSheet
 *
 * This file defines the native view interface used by Nitrogen to generate
 * the Swift/Kotlin bindings and JavaScript host component configuration.
 *
 * IMPORTANT: Run `yarn nitrogen` after any changes to regenerate bindings.
 */

import type {
  HybridView,
  HybridViewMethods,
  HybridViewProps,
} from 'react-native-nitro-modules';

// =============================================================================
// Detent Types (Native Bridge)
// =============================================================================

/**
 succeeded in 52ms:
import UIKit
import NitroModules

/**
 * HybridRnBottomSheet
 *
 * Native iOS implementation of the bottom sheet using UISheetPresentationController.
 * This class conforms to the generated HybridRnBottomSheetSpec protocol from Nitrogen.
 *
 * Key responsibilities:
 * - Present/dismiss native iOS sheets with React Native content
 * - Map detent configurations to UISheetPresentationController.Detent
 * - Handle lifecycle callbacks and state changes
 * - Bridge interaction events back to JavaScript
 */
class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {

    // =========================================================================
    // MARK: - UIView (required by HybridViewSpec)
    // =========================================================================
 succeeded in 52ms:
ios/RnBottomSheet.swift:86:    var grabberVisible: Bool = true {
ios/RnBottomSheet.swift:93:    var allowSwipeToDismiss: Bool = true {
ios/RnBottomSheet.swift:100:    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
ios/RnBottomSheet.swift:107:    var cornerRadius: Double = -1 {
ios/RnBottomSheet.swift:114:    var expandsWhenScrolledToEdge: Bool = true {
ios/RnBottomSheet.swift:147:    func snapToDetent(index: Double) throws {
ios/RnBottomSheet.swift:188:        contentVC.isModalInPresentation = !allowSwipeToDismiss
ios/RnBottomSheet.swift:191:            return self.allowSwipeToDismiss
ios/RnBottomSheet.swift:275:        sheet.prefersGrabberVisible = grabberVisible
ios/RnBottomSheet.swift:276:        sheet.prefersScrollingExpandsWhenScrolledToEdge = expandsWhenScrolledToEdge
ios/RnBottomSheet.swift:279:        if cornerRadius >= 0 {
ios/RnBottomSheet.swift:280:            sheet.preferredCornerRadius = CGFloat(cornerRadius)
ios/RnBottomSheet.swift:335:        switch backgroundInteraction {
ios/RnBottomSheet.swift:339:                sheet.largestUndimmedDetentIdentifier = nil
ios/RnBottomSheet.swift:341:                sheet.largestUndimmedDetentIdentifier = .large
ios/RnBottomSheet.swift:349:                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
ios/RnBottomSheet.swift:378:            sheet.prefersGrabberVisible = grabberVisible
ios/RnBottomSheet.swift:386:        contentVC.isModalInPresentation = !allowSwipeToDismiss
ios/RnBottomSheet.swift:409:            if cornerRadius >= 0 {
ios/RnBottomSheet.swift:410:                sheet.preferredCornerRadius = CGFloat(cornerRadius)

thinking
**Assessing true incomplete tasks**
exec
/bin/zsh -lc "sed -n '320,760p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' specs/001-native-ios-sheet-bindings/tasks.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg -n \"beforeUpdate|afterUpdate|thread|DispatchQueue|lock|synchronized\" ios src | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:

 succeeded in 52ms:
# Tasks: Native iOS Sheet Bindings

**Input**: Design documents from `/Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/`  
**Prerequisites**: plan.md (required), spec.md (required), research.md, data-model.md, contracts/, quickstart.md

**Tests**: Include tests because the specification requires automated verification coverage for API and integration behavior.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (`[US1]`, `[US2]`, `[US3]`)
- Include exact file paths in descriptions

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Prepare feature scaffolding, generated bindings workflow, and test harness entry points.

- [x] T001 Create feature README entry and scope note in docs/changelog-notes/README.md
 succeeded in 52ms:
                if #available(iOS 16.0, *) {
                    return .custom(identifier: definition.identifier) { context in
                        return min(CGFloat(value), context.maximumDetentValue)
                    }
                }
                return .medium()
            }
        }
    }

    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
        return buildValidatedDetentDefinitions().map(\.identifier)
    }

    private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
        switch backgroundInteraction {
        case .first(let mode):
            switch mode {
            case "modal":
                sheet.largestUndimmedDetentIdentifier = nil

thinking
**Assessing incomplete implementation tasks**
exec
/bin/zsh -lc "rg -n \"protocol HybridRnBottomSheetSpec|beforeUpdate|afterUpdate|prepareForRecycle|attach|detach\" ios nitrogen -g '*.swift' | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
ios/RnBottomSheet.swift:31:    /// Whether the host view is currently attached to a window hierarchy.
ios/RnBottomSheet.swift:34:    /// Tracks pending presentation requests while host view is detached.
ios/RnBottomSheet.swift:223:            // If UIKit already detached the presenter, reset state immediately.
ios/RnBottomSheet.swift:642:    func prepareForRecycle() {
ios/RnBottomSheet.swift:758:/// Nitro host view used as the content root and attach/detach lifecycle source.

thinking
**Listing nitrogen folder contents**
codex
I verified the first unchecked medium item is already implemented in `ios/RnBottomSheet.swift`, so I’m now identifying the first genuinely incomplete medium-priority item instead of duplicating work. I’ll inspect the remaining unchecked entries and pick the earliest one that still has a real gap.
exec
/bin/zsh -lc "rg -n \"\\- \\[ \\]\" IMPLEMENTATION_PLAN.md | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "ls -la nitrogen && find nitrogen -maxdepth 4 -type f | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg -n \"backgroundInteraction|grabberVisible|allowSwipeToDismiss|expandsWhenScrolledToEdge|cornerRadius|largestUndimmed|beforeUpdate|afterUpdate|thread-safety|thread safety|animated prop|unsupported full-transition|Maestro E2E|CI gates\" docs src ios example | sed -n '1,320p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
28:- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
29:- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
30:- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
31:- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
32:- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
33:- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
34:- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
35:- [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
44:- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
45:- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
52:- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
53:- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
63:- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
64:- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
65:- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
69:- [ ] [LOW] Update CI gates for new test coverage - from IMPLEMENTATION_PLAN Verification
 succeeded in 51ms:
total 0
drwxr-xr-x@  3 tolu  staff    96 Feb 12 02:30 .
drwxr-xr-x  46 tolu  staff  1472 Feb 12 02:30 ..
drwxr-xr-x@  6 tolu  staff   192 Feb 12 02:31 generated
nitrogen/generated/shared/c++/NativeDetentConfig.hpp
nitrogen/generated/shared/c++/HybridRnBottomSheetSpec.hpp
nitrogen/generated/shared/c++/HybridRnBottomSheetSpec.cpp
nitrogen/generated/shared/c++/NativeChangeReason.hpp
nitrogen/generated/shared/c++/NativeDetentType.hpp
nitrogen/generated/shared/json/RnBottomSheetConfig.json
nitrogen/generated/ios/RnBottomSheetAutolinking.mm
nitrogen/generated/ios/c++/HybridRnBottomSheetSpecSwift.cpp
nitrogen/generated/ios/c++/HybridRnBottomSheetSpecSwift.hpp
nitrogen/generated/ios/RnBottomSheetAutolinking.swift
nitrogen/generated/ios/RnBottomSheet-Swift-Cxx-Bridge.hpp
nitrogen/generated/ios/RnBottomSheet-Swift-Cxx-Bridge.cpp
nitrogen/generated/ios/swift/NativeBackgroundInteraction.swift
nitrogen/generated/ios/swift/NativeDetentType.swift
nitrogen/generated/ios/swift/Variant_String_Double.swift
nitrogen/generated/ios/swift/HybridRnBottomSheetSpec_cxx.swift
 succeeded in 51ms:
ios/RnBottomSheet.swift:86:    var grabberVisible: Bool = true {
ios/RnBottomSheet.swift:93:    var allowSwipeToDismiss: Bool = true {
ios/RnBottomSheet.swift:100:    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
ios/RnBottomSheet.swift:107:    var cornerRadius: Double = -1 {
ios/RnBottomSheet.swift:114:    var expandsWhenScrolledToEdge: Bool = true {
ios/RnBottomSheet.swift:188:        contentVC.isModalInPresentation = !allowSwipeToDismiss
ios/RnBottomSheet.swift:191:            return self.allowSwipeToDismiss
ios/RnBottomSheet.swift:275:        sheet.prefersGrabberVisible = grabberVisible
ios/RnBottomSheet.swift:276:        sheet.prefersScrollingExpandsWhenScrolledToEdge = expandsWhenScrolledToEdge
ios/RnBottomSheet.swift:279:        if cornerRadius >= 0 {
ios/RnBottomSheet.swift:280:            sheet.preferredCornerRadius = CGFloat(cornerRadius)
ios/RnBottomSheet.swift:335:        switch backgroundInteraction {
ios/RnBottomSheet.swift:339:                sheet.largestUndimmedDetentIdentifier = nil
ios/RnBottomSheet.swift:341:                sheet.largestUndimmedDetentIdentifier = .large
ios/RnBottomSheet.swift:349:                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
ios/RnBottomSheet.swift:378:            sheet.prefersGrabberVisible = grabberVisible
ios/RnBottomSheet.swift:386:        contentVC.isModalInPresentation = !allowSwipeToDismiss
ios/RnBottomSheet.swift:409:            if cornerRadius >= 0 {
ios/RnBottomSheet.swift:410:                sheet.preferredCornerRadius = CGFloat(cornerRadius)
ios/RnBottomSheet.swift:423:            sheet.prefersScrollingExpandsWhenScrolledToEdge = expandsWhenScrolledToEdge

thinking
**Inspecting threading and concurrency approach**
exec
/bin/zsh -lc "sed -n '1,260p' nitrogen/generated/ios/swift/HybridRnBottomSheetSpec.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' nitrogen/generated/ios/swift/HybridRnBottomSheetSpec_cxx.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' docs/references/nitro-view-components.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
# Nitro View Components Notes

## Why It Matters

This project is implemented as a Nitro View, so Nitro lifecycle and threading rules are core to correctness.

## Key Constraints

1. Nitro Views require React Native 0.78+ and New Architecture/Fabric.
2. A `*.nitro.ts` declaration drives generated ShadowNode/config/code bindings.
3. JS host registration uses `getHostComponent(...)` + generated view config JSON.
4. Props can arrive from different threads (React path vs `hybridRef` path), so native code must be thread-safe.
5. `beforeUpdate()` and `afterUpdate()` can be used to batch prop application.
6. Callback props in Nitro Views require wrapping (`callback(...)`) due to React Native core function handling.
7. Recycled views must implement `RecyclableView.prepareForRecycle()` to avoid stale content.

## Implications for rn-bottom-sheet

1. Native sheet presenter state cannot assume a single-thread write path.
2. Cleanup must be deterministic for reused views.
 succeeded in 51ms:
///
/// HybridRnBottomSheetSpec.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright © Marc Rousavy @ Margelo
///

import NitroModules

/// See ``HybridRnBottomSheetSpec``
public protocol HybridRnBottomSheetSpec_protocol: HybridObject, HybridView {
  // Properties
  var detents: [NativeDetentConfig] { get set }
  var initialDetentIndex: Double { get set }
  var selectedDetentIndex: Double { get set }
  var isOpen: Bool { get set }
  var grabberVisible: Bool { get set }
  var allowSwipeToDismiss: Bool { get set }
  var backgroundInteraction: NativeBackgroundInteraction { get set }
  var cornerRadius: Double { get set }
 succeeded in 51ms:
///
/// HybridRnBottomSheetSpec_cxx.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright © Marc Rousavy @ Margelo
///

import NitroModules

/**
 * A class implementation that bridges HybridRnBottomSheetSpec over to C++.
 * In C++, we cannot use Swift protocols - so we need to wrap it in a class to make it strongly defined.
 *
 * Also, some Swift types need to be bridged with special handling:
 * - Enums need to be wrapped in Structs, otherwise they cannot be accessed bi-directionally (Swift bug: https://github.com/swiftlang/swift/issues/75330)
 * - Other HybridObjects need to be wrapped/unwrapped from the Swift TCxx wrapper
 * - Throwing methods need to be wrapped with a Result<T, Error> type, as exceptions cannot be propagated to C++
 */
open class HybridRnBottomSheetSpec_cxx {
  /**

thinking
**Inspecting protocol lifecycle methods**
exec
/bin/zsh -lc "rg -n \"protocol HybridView|beforeUpdate|afterUpdate|attachToView|detachFromView|prepareForRecycle\" node_modules/react-native-nitro-modules ios -g '*.swift' | sed -n '1,300p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 50ms:
ios/RnBottomSheet.swift:642:    func prepareForRecycle() {
node_modules/react-native-nitro-modules/ios/views/HybridView.swift:13:  public protocol HybridView: HybridObject {
node_modules/react-native-nitro-modules/ios/views/HybridView.swift:26:    func beforeUpdate()
node_modules/react-native-nitro-modules/ios/views/HybridView.swift:31:    func afterUpdate()
node_modules/react-native-nitro-modules/ios/views/HybridView.swift:35:    public func beforeUpdate() { /* noop */  }
node_modules/react-native-nitro-modules/ios/views/HybridView.swift:36:    public func afterUpdate() { /* noop */  }
node_modules/react-native-nitro-modules/ios/views/RecyclableView.swift:17:  func prepareForRecycle()
exec
/bin/zsh -lc "sed -n '1,220p' node_modules/react-native-nitro-modules/ios/views/HybridView.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
//
//  HybridView.swift
//  NitroModules
//
//  Created by Marc Rousavy on 13.01.25.
//

#if canImport(UIKit)

  import UIKit

  /// A base protocol for all Swift-based Hybrid Views.
  public protocol HybridView: HybridObject {
    associatedtype ViewType: UIView
    /**
     * Get the ``UIView`` this HybridView is holding.
     *
     * This value should not change during the lifetime of this ``HybridView``.
     */
    var view: ViewType { get }


thinking
**Designing thread-safe prop updates**
thinking
**Finalizing thread-safe batch updates and plan sync**
Plan update
Entering plan mode for this non-trivial Ralph iteration. I verified the top unchecked medium items in IMPLEMENTATION_PLAN are stale-complete, so the first genuinely incomplete medium item is native thread-safety for cross-thread prop updates (plus adjacent beforeUpdate/afterUpdate batching).
  → Write this iteration plan to tasks/todo.md with checkable items and sync scope before code edits
  • Implement iOS thread-safe prop/method access in ios/RnBottomSheet.swift using main-thread marshaling
  • Implement HybridView beforeUpdate()/afterUpdate() batching hooks in ios/RnBottomSheet.swift for grouped prop updates
  • Update IMPLEMENTATION_PLAN.md checkboxes to reflect true completion state for verified stale-complete tasks
  • Run verification gates (yarn lint, yarn typecheck, yarn test, and iOS example build) and fix any regressions
  • Record results in tasks/todo.md Review, commit with descriptive message, and push

thinking
**Planning task list update**
codex
Plan check-in before implementation: I’m logging a new Ralph iteration in `tasks/todo.md` with explicit unchecked steps, then I’ll implement the thread-safety + batch-update hooks in `ios/RnBottomSheet.swift` and re-run full verification including iOS build.
exec
/bin/zsh -lc "cat <<'EOF' >> tasks/todo.md

## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)

- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in "'`ios/RnBottomSheet.swift`
- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
- [ ] Capture verification outcomes in the Review section
EOF' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:


thinking
**Planning full file inspection**
exec
/bin/zsh -lc "sed -n '260,560p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '560,900p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:

    private func configureSheetController(_ sheet: UISheetPresentationController) {
        let nativeDetents = buildNativeDetents()
        let detentIdentifiers = buildNativeDetentIdentifiers()

        // Set detents
        sheet.detents = nativeDetents

        // Set initial selection
        let initialIndex = Int(initialDetentIndex)
        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
        }

        // Configure appearance
        sheet.prefersGrabberVisible = grabberVisible
        sheet.prefersScrollingExpandsWhenScrolledToEdge = expandsWhenScrolledToEdge

        // Configure corner radius
        if cornerRadius >= 0 {
 succeeded in 52ms:
import UIKit
import NitroModules

/**
 * HybridRnBottomSheet
 *
 * Native iOS implementation of the bottom sheet using UISheetPresentationController.
 * This class conforms to the generated HybridRnBottomSheetSpec protocol from Nitrogen.
 *
 * Key responsibilities:
 * - Present/dismiss native iOS sheets with React Native content
 * - Map detent configurations to UISheetPresentationController.Detent
 * - Handle lifecycle callbacks and state changes
 * - Bridge interaction events back to JavaScript
 */
class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {

    // =========================================================================
    // MARK: - UIView (required by HybridViewSpec)
    // =========================================================================
 succeeded in 52ms:
            return $0.sortValue < $1.sortValue
        }
    }

    private func numericValue(from raw: Variant_String_Double) -> Double? {
        switch raw {
        case .first:
            return nil
        case .second(let value):
            return value
        }
    }

    private func stringValue(from raw: Variant_String_Double) -> String? {
        switch raw {
        case .first(let value):
            return value
        case .second:
            return nil
        }

thinking
**Inspecting file end for extensions**
exec
/bin/zsh -lc "sed -n '900,1120p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
    }

    private func wasBackdropTapRecently() -> Bool {
        guard let tapTimestamp = lastBackdropTapTimestamp else {
            return false
        }

        let now = Date().timeIntervalSinceReferenceDate
        return (now - tapTimestamp) <= backdropDismissalInferenceWindow
    }

    private func clearDismissalTracking() {
        dismissalReasonOverride = nil
        isSystemDismissalCandidate = false
        wasInteractiveDismissal = nil
        lastBackdropTapTimestamp = nil
    }
}

extension SheetContentViewController: UIGestureRecognizerDelegate {

thinking
**Designing batched prop updates**
codex
I’ve confirmed the real gap is native thread safety for cross-thread prop updates, and I’m now editing `ios/RnBottomSheet.swift` to marshal all prop/method access onto the main thread and add Nitro `beforeUpdate`/`afterUpdate` batching.
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -48,2 +48,7 @@
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
@@ -59,5 +64,14 @@
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
@@ -66,11 +80,30 @@
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
@@ -78,6 +111,15 @@
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
@@ -85,6 +127,15 @@
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
@@ -92,5 +143,14 @@
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
@@ -99,6 +159,15 @@
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
@@ -106,6 +175,15 @@
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
@@ -113,6 +191,15 @@
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
         }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
+        }
     }
@@ -123,8 +210,85 @@
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
@@ -135,5 +299,7 @@
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
@@ -141,5 +307,7 @@
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
@@ -147,3 +315,5 @@
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
@@ -151,3 +321,22 @@
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..ceb340e28ad99bf4e22ab1a01864f42d768fccda
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -46,6 +46,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,99 +62,283 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
         }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
+        }
     }
 
     // =========================================================================
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..ceb340e28ad99bf4e22ab1a01864f42d768fccda
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -46,6 +46,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,99 +62,283 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
         }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
+        }
     }
 
     // =========================================================================
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================


thinking
**Adding pending update enum and main-thread helpers**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -348,6 +348,6 @@
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
@@ -357,2 +357,53 @@
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
@@ -398,3 +449,3 @@
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..ad7262fb2739ec863f14aa1c292beee8146fdf08
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -46,6 +46,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +62,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +208,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +447,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..ad7262fb2739ec863f14aa1c292beee8146fdf08
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -46,6 +46,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +62,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +208,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +447,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }


thinking
**Defining missing enum type**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -16,2 +16,12 @@
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..e55eefd8a745c45ca18010d3a26010aa68ecff16
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
         }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
+        }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
         }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
         }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,35 +218,137 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================
@@ -157,15 +356,66 @@
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..e55eefd8a745c45ca18010d3a26010aa68ecff16
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
         }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
+        }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
         }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
         }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
+        }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
         }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,35 +218,137 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================
@@ -157,15 +356,66 @@
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }


thinking
**Preparing patch for main thread sync**
codex
I’ve added the core main-thread marshaling and batched update queue. I’m now finishing the integration by wrapping delegate/recycle entry points and resetting batched state cleanly so recycle and lifecycle paths remain deterministic.
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -853,13 +853,15 @@
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
@@ -868,5 +870,7 @@
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
@@ -874,6 +878,8 @@
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
@@ -882,8 +888,10 @@
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
@@ -892,35 +900,40 @@
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..4d1f214963c168e58e266f479e33836e479a9c41
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
         }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
         }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,35 +218,137 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================
@@ -157,15 +356,66 @@
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..4d1f214963c168e58e266f479e33836e479a9c41
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
         }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
         }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,35 +218,137 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
     }
 
     // =========================================================================
@@ -157,15 +356,66 @@
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 


thinking
**Refactoring state storage and main-thread sync**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -947,3 +947,5 @@
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
@@ -951,6 +953,8 @@
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Assessing thread-safety updates**
exec
/bin/zsh -lc "sed -n '18,90p' IMPLEMENTATION_PLAN.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
### Phase 2: iOS Sheet Engine

- [x] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
- [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture

### Phase 3: Content Hosting
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Deciding key state markings**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/IMPLEMENTATION_PLAN.md
@@ -27,9 +27,9 @@
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
@@ -43,4 +43,4 @@
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
@@ -51,4 +51,4 @@
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
@@ -62,5 +62,5 @@
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M IMPLEMENTATION_PLAN.md
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Planning thread-safety and syntax checks**
exec
/bin/zsh -lc "git diff -- ios/RnBottomSheet.swift | sed -n '1,320p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876..9d4dda9 100644
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@ import NitroModules
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Continuing diff inspection**
exec
/bin/zsh -lc "git diff -- ios/RnBottomSheet.swift | sed -n '320,700p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..9d4dda94028ff888e5fa21023fd540da0f5db738
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
             }
         }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
+            }
+        }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
         }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
+        }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
         }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,204 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
 
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
     }
 
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
+    }
+
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        return DispatchQueue.main.sync {
+            work()
+        }
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +457,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +851,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +945,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Refactoring main-thread sync to avoid concurrency warnings**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -408,3 +408,3 @@
 
-    private func runOnMainSync<T>(_ work: @escaping () -> T) -> T {
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
         if Thread.isMainThread {
@@ -413,5 +413,9 @@
 
-        return DispatchQueue.main.sync {
-            work()
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
         }
+        return result ?? {
+            work()
+        }()
     }
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..73b8a25392e8c82f0ab4d00f3afafca350850e8a
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,208 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
 
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        return result ?? {
+            work()
+        }()
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +461,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +855,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +949,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..73b8a25392e8c82f0ab4d00f3afafca350850e8a
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,208 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
 
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
+
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        return result ?? {
+            work()
+        }()
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +461,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +855,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +949,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Refining fallback logic**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -417,5 +417,6 @@
         }
-        return result ?? {
-            work()
-        }()
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
     }
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M ios/RnBottomSheet.swift
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Preparing verification steps**
codex
Implementation edits are in place. I’m running the full validation gate now (`lint`, `typecheck`, `test`, and example iOS build) to prove the threading/batching changes are correct before I update task state and commit.
exec
/bin/zsh -lc 'yarn lint' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'yarn typecheck' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.22s:

 succeeded in 2.96s:

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Running tests and iOS build**
exec
/bin/zsh -lc 'yarn test' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'yarn workspace rn-bottom-sheet-example ios' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.04s:
watchman warning:  Recrawled this watch 1 time, most recently because:
MustScanSubDirs UserDroppedTo resolve, please review the information on
https://facebook.github.io/watchman/docs/troubleshooting.html#recrawl
To clear this warning, run:
`watchman watch-del '/Users/tolu/Desktop/dev/rn-bottom-sheet' ; watchman watch-project '/Users/tolu/Desktop/dev/rn-bottom-sheet'`

PASS src/__tests__/bottom-sheet.detent.integration.test.tsx
PASS example/src/__tests__/sheet-open-dismiss.integration.test.tsx
PASS src/__tests__/bottom-sheet.presenter.integration.test.tsx
PASS src/__tests__/bottom-sheet.reanimated.test.ts
PASS src/__tests__/bottom-sheet-adapter.test.ts
PASS src/__tests__/bottom-sheet.wrapper.test.ts
PASS src/__tests__/bottom-sheet.fallback.test.ts
PASS src/__tests__/bottom-sheet.navigation.test.ts
PASS src/__tests__/bottom-sheet.methods.test.ts
PASS src/__tests__/bottom-sheet.contract.test.ts
PASS src/__tests__/bottom-sheet.lifecycle.test.ts
PASS src/__tests__/bottom-sheet.detents.test.ts
PASS src/__tests__/index.test.tsx

 succeeded in 28.91s:
› Skipping dev server
› Planning build
› Executing expo-dev-menu-interface Pods/expo-dev-menu-interface » Copy generated compatibility header
    Run script build phase '[CP-User] [Hermes] Replace Hermes for the right configuration, if needed' will be run during every build because it does not specify any outputs. To address this issue, either add output dependencies to the script phase, or configure it to run in every build by unchecking "Based on dependency analysis" in the script phase. (in target 'hermes-engine' from project 'Pods')
› Executing react-native Pods/hermes-engine » [CP-User] [Hermes] Replace Hermes for the right configuration, if needed
› Executing react-native Pods/hermes-engine » [CP] Copy XCFrameworks
› Executing react-native Pods/ReactNativeDependencies » [CP-User] [RNDeps] Replace React Native Dependencies for the right configuration, if needed
› Executing react-native Pods/ReactNativeDependencies » [CP] Copy XCFrameworks
› Executing react-native Pods/React-Core-prebuilt » [CP-User] [RNDeps] Replace React Native Core for the right configuration, if needed
› Executing react-native Pods/React-Core-prebuilt » [CP] Copy XCFrameworks
› Preparing Pods/React-cxxreact-React-cxxreact_privacy » ResourceBundle-React-cxxreact_privacy-React-cxxreact-Info.plist
› Preparing Pods/React-Core-React-Core_privacy » ResourceBundle-React-Core_privacy-React-Core-Info.plist
› Executing react-native Pods/React-RCTFBReactNativeSpec » [CP-User] [RN]Check FBReactNativeSpec
› Executing rn-bottom-sheet-example Pods/ReactCodegen » [CP-User] Generate Specs
› Compiling rn-bottom-sheet-example Pods/ReactCodegen » NitroModulesSpec-generated.mm
› Compiling react-native-nitro-modules Pods/NitroModules » NativeNitroModules+NewArch.mm
› Compiling rn-bottom-sheet-example Pods/ReactCodegen » RCTUnstableModulesRequiringMainQueueSetupProvider.mm
› Compiling rn-bottom-sheet-example Pods/ReactCodegen » RCTThirdPartyComponentsProvider.mm
› Compiling rn-bottom-sheet-example Pods/ReactCodegen » RCTModulesConformingToProtocolsProvider.mm
› Compiling rn-bottom-sheet-example Pods/ReactCodegen » RCTModuleProviders.mm
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Planning review section update**
exec
/bin/zsh -lc "sed -n '1,120p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
# Implementation Todo

## Phase 0: Project Memory Bootstrap

- [x] Create `docs/` knowledge base structure
- [x] Add decision-complete implementation plan
- [x] Add reference summaries and source index
- [x] Add ADRs for primary architecture decisions
- [x] Add sync/check scripts for docs integrity

## Phase 1: API and Nitro Contract

- [x] Finalize public TypeScript API and Nitro view contract
- [x] Regenerate Nitrogen artifacts
- [x] Validate typings and exports

## Phase 2: iOS Sheet Engine

- [ ] Implement presenter/controller architecture
- [ ] Map detent model and lifecycle events
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Planning insertion and patching**
exec
/bin/zsh -lc 'rg -n "Phase 3 Thread-Safe Prop Updates|Run and pass verification" tasks/todo.md | tail -n 20' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
247:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
256:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
265:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
274:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
283:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
292:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
300:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
310:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
318:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
326:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
334:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
342:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn docs:check`
351:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
359:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
368:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn docs:check`
376:- [x] Run and pass verification: `yarn workspace rn-bottom-sheet-example ios`, `yarn lint`, `yarn typecheck`, `yarn test`
384:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
392:- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
395:## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
401:- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Reviewing file end lines**
exec
/bin/zsh -lc "sed -n '390,450p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
- [x] Implement a native sheet host container view for RN children with explicit attach/detach lifecycle hooks in `ios/RnBottomSheet.swift`
- [x] Implement `prepareForRecycle()` cleanup to reset presenter/session state safely for Nitro view reuse in `ios/RnBottomSheet.swift`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
- [x] Update `IMPLEMENTATION_PLAN.md` and `tasks/todo.md` Review with outcomes

## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)

- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
- [ ] Capture verification outcomes in the Review section
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 


thinking
**Planning patch for marks and review bullets**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
@@ -62,2 +62,7 @@
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
@@ -396,7 +401,7 @@
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M tasks/todo.md
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Planning status updates and checks**
exec
/bin/zsh -lc 'git status --short --branch' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
## main...origin/main
 M .specify/templates/plan-template.md
 M .specify/templates/spec-template.md
 M IMPLEMENTATION_PLAN.md
 M PROMPT_build.md
 M PROMPT_plan.md
 M ios/RnBottomSheet.swift
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
 M tasks/todo.md
?? logs/
?? yarn.lock
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Staging only relevant files**
codex
Validation passed, and I’ve updated task tracking/review notes. Next I’m preparing a focused commit for this iteration’s files (`ios/RnBottomSheet.swift`, `IMPLEMENTATION_PLAN.md`, `tasks/todo.md`) so unrelated local changes stay untouched, then I’ll push.
exec
/bin/zsh -lc "git diff -- tasks/todo.md | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "git diff -- IMPLEMENTATION_PLAN.md | sed -n '1,220p'" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "git diff -- ios/RnBottomSheet.swift | sed -n '1,320p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
diff --git a/tasks/todo.md b/tasks/todo.md
index 24f50de..bde7b82 100644
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -391,3 +396,12 @@
 - [x] Implement `prepareForRecycle()` cleanup to reset presenter/session state safely for Nitro view reuse in `ios/RnBottomSheet.swift`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
 - [x] Update `IMPLEMENTATION_PLAN.md` and `tasks/todo.md` Review with outcomes
 succeeded in 51ms:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b261..fececaa 100644
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
 succeeded in 51ms:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876..a20ac9d 100644
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@ import NitroModules
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Staging selective files for commit**
exec
/bin/zsh -lc 'git add ios/RnBottomSheet.swift IMPLEMENTATION_PLAN.md tasks/todo.md && git commit -m "iOS: make Nitro prop updates main-thread safe and batched"' in /Users/tolu/Desktop/dev/rn-bottom-sheet exited 1 in 543ms:
┃  commitlint ❯ 

[1G[0K⠙[1G[0K[90m⧗[39m   input: [1miOS: make Nitro prop updates main-thread safe and batched[22m
[31m✖[39m   type must be lower-case [90m[type-case][39m
[31m✖[39m   type must be one of [build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] [90m[type-enum][39m

[1m[31m✖[39m   found 2 problems, 0 warnings[22m
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint

[1G[0K⠙[1G[0K
exit status 1                                      
  ────────────────────────────────────
summary: (done in 0.51 seconds)       
🥊 commitlint (0.51 seconds)
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Recommitting with conventional message**
exec
/bin/zsh -lc 'git commit -m "fix(ios): make nitro prop updates main-thread safe and batched"' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 328ms:
┃  commitlint ❯ 

[1G[0K[1G[0K⠙[1G[0K
                                      
  ────────────────────────────────────
summary: (done in 0.32 seconds)       
✔️ commitlint (0.32 seconds)
[main 8e9f49f] fix(ios): make nitro prop updates main-thread safe and batched
 3 files changed, 401 insertions(+), 115 deletions(-)
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Preparing to push commits**
exec
/bin/zsh -lc 'git push' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 827ms:
To https://github.com/tolulawson/rn-bottom-sheet.git
   0bfbb0d..8e9f49f  main -> main
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Confirming plan completion**
Plan update
  ✓ Write this iteration plan to tasks/todo.md with checkable items and sync scope before code edits
  ✓ Implement iOS thread-safe prop/method access in ios/RnBottomSheet.swift using main-thread marshaling
  ✓ Implement HybridView beforeUpdate()/afterUpdate() batching hooks in ios/RnBottomSheet.swift for grouped prop updates
  ✓ Update IMPLEMENTATION_PLAN.md checkboxes to reflect true completion state for verified stale-complete tasks
  ✓ Run verification gates (yarn lint, yarn typecheck, yarn test, and iOS example build) and fix any regressions
  ✓ Record results in tasks/todo.md Review, commit with descriptive message, and push
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section


thinking
**Confirming final completion phrase**
codex
<promise>DONE</promise>
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 5e0b2613b11f3ef16c0a7bfa05e13c7cba99d8b9..fececaaf7a54ce1838f36b4b3c6380c98838f49c
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -25,13 +25,13 @@
 - [x] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
 - [x] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
-- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
+- [x] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
+- [x] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
 - [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
 
 ### Phase 3: Content Hosting
@@ -41,16 +41,16 @@
 - [x] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
 - [x] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
-- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
-- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
+- [x] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
+- [x] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md
 
 ### Phase 4: Integrations
 
 - [x] [MEDIUM] Create navigation subpath structure (rn-bottom-sheet/navigation) - from ADR-0003
 - [x] [MEDIUM] Implement useBottomSheetNavigation hook for nested navigators - from react-navigation-form-sheet.md
 - [x] [MEDIUM] Add Reanimated createAnimatedComponent compatibility - from reanimated-interop.md
-- [ ] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
-- [ ] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
+- [x] [MEDIUM] Document supported animated prop pathways - from reanimated-interop.md
+- [x] [LOW] Document unsupported full-transition control expectations - from reanimated-interop.md
 - [x] [LOW] Implement Android/Web safe fallback (no crash, explicit warning) - from IMPLEMENTATION_PLAN Platform Behavior
 - [x] [LOW] Add platform check guards in JS layer - from IMPLEMENTATION_PLAN Platform Behavior
 
@@ -60,9 +60,9 @@
 - [x] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [x] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
-- [ ] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: open sheet, verify visible - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: change detents, verify positions - from IMPLEMENTATION_PLAN Verification
+- [x] [MEDIUM] Add Maestro E2E flow: dismiss sheet, verify closed - from IMPLEMENTATION_PLAN Verification
 - [x] [MEDIUM] Fix yarn lint to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Fix yarn typecheck to pass - from tasks/todo.md Verification Checklist
 - [x] [MEDIUM] Verify iOS example app builds successfully - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 66c2876cdfe006b319f4422eda12f1fcb73342e5..a20ac9d50192b26f8fe10fb77e7970381bcf1c6f
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -14,6 +14,16 @@
  * - Bridge interaction events back to JavaScript
  */
 class HybridRnBottomSheet: HybridRnBottomSheetSpec, RecyclableView {
+    private enum PendingPropUpdate: Hashable {
+        case detents
+        case selectedDetent
+        case openState
+        case grabberVisible
+        case allowSwipeToDismiss
+        case backgroundInteraction
+        case cornerRadius
+        case expandsWhenScrolledToEdge
+    }
 
     // =========================================================================
     // MARK: - UIView (required by HybridViewSpec)
@@ -46,6 +56,11 @@
     /// Suppress one delegate callback after programmatic detent changes to avoid duplicate events
     private var suppressNextDetentDelegateEvent: Bool = false
 
+    /// Nitro prop updates are wrapped in before/after hooks; stage updates to apply once per batch.
+    private var isBatchUpdatingProps: Bool = false
+    private var pendingPropUpdates: Set<PendingPropUpdate> = []
+    private var appliedIsOpenState: Bool = false
+
     override init() {
         self.view = SheetHostContainerView()
         super.init()
@@ -57,63 +72,145 @@
     // =========================================================================
 
     /// Detent configurations
-    var detents: [NativeDetentConfig] = [] {
-        didSet {
-            updateDetentsIfPresented()
+    private var detentsStorage: [NativeDetentConfig] = []
+    var detents: [NativeDetentConfig] {
+        get {
+            runOnMainSync {
+                detentsStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                detentsStorage = newValue
+                queuePropUpdate(.detents)
+            }
         }
     }
 
     /// Initial detent index when sheet opens
-    var initialDetentIndex: Double = 0
+    private var initialDetentIndexStorage: Double = 0
+    var initialDetentIndex: Double {
+        get {
+            runOnMainSync {
+                initialDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                initialDetentIndexStorage = newValue
+            }
+        }
+    }
 
     /// Selected detent index (-1 for uncontrolled)
-    var selectedDetentIndex: Double = -1 {
-        didSet {
-            if selectedDetentIndex >= 0 {
-                snapToDetentInternal(Int(selectedDetentIndex), animated: true)
+    private var selectedDetentIndexStorage: Double = -1
+    var selectedDetentIndex: Double {
+        get {
+            runOnMainSync {
+                selectedDetentIndexStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                selectedDetentIndexStorage = newValue
+                queuePropUpdate(.selectedDetent)
             }
         }
     }
 
     /// Whether sheet should be open
-    var isOpen: Bool = false {
-        didSet {
-            handleOpenStateChange(oldValue: oldValue)
+    private var isOpenStorage: Bool = false
+    var isOpen: Bool {
+        get {
+            runOnMainSync {
+                isOpenStorage
+            }
         }
+        set {
+            runOnMainSync {
+                isOpenStorage = newValue
+                queuePropUpdate(.openState)
+            }
+        }
     }
 
     /// Show grabber handle
-    var grabberVisible: Bool = true {
-        didSet {
-            updateGrabberVisibility()
+    private var grabberVisibleStorage: Bool = true
+    var grabberVisible: Bool {
+        get {
+            runOnMainSync {
+                grabberVisibleStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                grabberVisibleStorage = newValue
+                queuePropUpdate(.grabberVisible)
+            }
         }
     }
 
     /// Allow swipe to dismiss
-    var allowSwipeToDismiss: Bool = true {
-        didSet {
-            updateSwipeToDismiss()
+    private var allowSwipeToDismissStorage: Bool = true
+    var allowSwipeToDismiss: Bool {
+        get {
+            runOnMainSync {
+                allowSwipeToDismissStorage
+            }
         }
+        set {
+            runOnMainSync {
+                allowSwipeToDismissStorage = newValue
+                queuePropUpdate(.allowSwipeToDismiss)
+            }
+        }
     }
 
     /// Background interaction mode
-    var backgroundInteraction: NativeBackgroundInteraction = .first("modal") {
-        didSet {
-            updateBackgroundInteraction()
+    private var backgroundInteractionStorage: NativeBackgroundInteraction = .first("modal")
+    var backgroundInteraction: NativeBackgroundInteraction {
+        get {
+            runOnMainSync {
+                backgroundInteractionStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                backgroundInteractionStorage = newValue
+                queuePropUpdate(.backgroundInteraction)
+            }
         }
     }
 
     /// Corner radius (-1 for system default)
-    var cornerRadius: Double = -1 {
-        didSet {
-            updateCornerRadius()
+    private var cornerRadiusStorage: Double = -1
+    var cornerRadius: Double {
+        get {
+            runOnMainSync {
+                cornerRadiusStorage
+            }
         }
+        set {
+            runOnMainSync {
+                cornerRadiusStorage = newValue
+                queuePropUpdate(.cornerRadius)
+            }
+        }
     }
 
     /// Expand when scrolled to edge
-    var expandsWhenScrolledToEdge: Bool = true {
-        didSet {
-            updateExpandsWhenScrolledToEdge()
+    private var expandsWhenScrolledToEdgeStorage: Bool = true
+    var expandsWhenScrolledToEdge: Bool {
+        get {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                expandsWhenScrolledToEdgeStorage = newValue
+                queuePropUpdate(.expandsWhenScrolledToEdge)
+            }
         }
     }
 
@@ -121,51 +218,209 @@
     // MARK: - Callbacks (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
-    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
-    var onWillPresent: () -> Void = {}
-    var onDidPresent: () -> Void = {}
-    var onWillDismiss: () -> Void = {}
-    var onDidDismiss: () -> Void = {}
+    private var onOpenChangeStorage: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onOpenChange: (_ isOpen: Bool, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onOpenChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onOpenChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onDetentChangeStorage: (_ index: Double, _ reason: NativeChangeReason) -> Void = { _, _ in }
+    var onDetentChange: (_ index: Double, _ reason: NativeChangeReason) -> Void {
+        get {
+            runOnMainSync {
+                onDetentChangeStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDetentChangeStorage = newValue
+            }
+        }
+    }
+
+    private var onWillPresentStorage: () -> Void = {}
+    var onWillPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onWillPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onDidPresentStorage: () -> Void = {}
+    var onDidPresent: () -> Void {
+        get {
+            runOnMainSync {
+                onDidPresentStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidPresentStorage = newValue
+            }
+        }
+    }
+
+    private var onWillDismissStorage: () -> Void = {}
+    var onWillDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onWillDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onWillDismissStorage = newValue
+            }
+        }
+    }
+
+    private var onDidDismissStorage: () -> Void = {}
+    var onDidDismiss: () -> Void {
+        get {
+            runOnMainSync {
+                onDidDismissStorage
+            }
+        }
+        set {
+            runOnMainSync {
+                onDidDismissStorage = newValue
+            }
+        }
+    }
 
     // =========================================================================
     // MARK: - Methods (conforming to HybridRnBottomSheetSpec)
     // =========================================================================
 
     func present() throws {
-        guard !isCurrentlyPresented else { return }
-        shouldPresentWhenHostAttaches = true
-        presentSheet()
+        runOnMainSync {
+            guard !isCurrentlyPresented else { return }
+            shouldPresentWhenHostAttaches = true
+            presentSheet()
+        }
     }
 
     func dismiss() throws {
-        shouldPresentWhenHostAttaches = false
-        guard isCurrentlyPresented else { return }
-        dismissSheet(reason: .programmatic)
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            guard isCurrentlyPresented else { return }
+            dismissSheet(reason: .programmatic)
+        }
     }
 
     func snapToDetent(index: Double) throws {
-        snapToDetentInternal(Int(index), animated: true)
+        runOnMainSync {
+            snapToDetentInternal(Int(index), animated: true)
+        }
     }
 
     func getCurrentDetentIndex() throws -> Double {
-        return Double(currentDetentIndex)
+        runOnMainSync {
+            Double(currentDetentIndex)
+        }
+    }
+
+    func beforeUpdate() {
+        runOnMainSync {
+            isBatchUpdatingProps = true
+        }
     }
 
+    func afterUpdate() {
+        runOnMainSync {
+            guard isBatchUpdatingProps else { return }
+            isBatchUpdatingProps = false
+
+            let updates = pendingPropUpdates
+            pendingPropUpdates.removeAll()
+            applyQueuedPropUpdates(updates)
+        }
+    }
+
     // =========================================================================
     // MARK: - Private Implementation
     // =========================================================================
 
     private func handleOpenStateChange(oldValue: Bool) {
-        if isOpen && !oldValue {
+        if isOpenStorage && !oldValue {
             shouldPresentWhenHostAttaches = true
             presentSheet()
-        } else if !isOpen && oldValue {
+        } else if !isOpenStorage && oldValue {
             shouldPresentWhenHostAttaches = false
             dismissSheet(reason: .programmatic)
         }
     }
 
+    private func queuePropUpdate(_ update: PendingPropUpdate) {
+        precondition(Thread.isMainThread, "Prop updates must be queued on main thread")
+        if isBatchUpdatingProps {
+            pendingPropUpdates.insert(update)
+            return
+        }
+        applyQueuedPropUpdates([update])
+    }
+
+    private func applyQueuedPropUpdates(_ updates: Set<PendingPropUpdate>) {
+        precondition(Thread.isMainThread, "Queued prop updates must be applied on main thread")
+        guard !updates.isEmpty else { return }
+
+        if updates.contains(.detents) {
+            updateDetentsIfPresented()
+        }
+        if updates.contains(.grabberVisible) {
+            updateGrabberVisibility()
+        }
+        if updates.contains(.allowSwipeToDismiss) {
+            updateSwipeToDismiss()
+        }
+        if updates.contains(.backgroundInteraction) {
+            updateBackgroundInteraction()
+        }
+        if updates.contains(.cornerRadius) {
+            updateCornerRadius()
+        }
+        if updates.contains(.expandsWhenScrolledToEdge) {
+            updateExpandsWhenScrolledToEdge()
+        }
+        if updates.contains(.selectedDetent), selectedDetentIndexStorage >= 0 {
+            snapToDetentInternal(Int(selectedDetentIndexStorage), animated: true)
+        }
+        if updates.contains(.openState), isOpenStorage != appliedIsOpenState {
+            let previousOpenState = appliedIsOpenState
+            appliedIsOpenState = isOpenStorage
+            handleOpenStateChange(oldValue: previousOpenState)
+        }
+    }
+
+    private func runOnMainSync<T>(_ work: () -> T) -> T {
+        if Thread.isMainThread {
+            return work()
+        }
+
+        var result: T?
+        DispatchQueue.main.sync {
+            result = work()
+        }
+        guard let unwrappedResult = result else {
+            fatalError("runOnMainSync did not produce a result")
+        }
+        return unwrappedResult
+    }
+
     private func presentSheet() {
         guard isHostAttached else {
             shouldPresentWhenHostAttaches = true
@@ -207,7 +462,7 @@
         presentingVC.present(contentVC, animated: true) { [weak self] in
             self?.isCurrentlyPresented = true
             self?.shouldPresentWhenHostAttaches = false
-            self?.currentDetentIndex = Int(self?.initialDetentIndex ?? 0)
+            self?.currentDetentIndex = Int(self?.initialDetentIndexStorage ?? 0)
             self?.onDidPresent()
             self?.onOpenChange(true, .programmatic)
         }
@@ -601,78 +856,91 @@
     }
 
     fileprivate func handleDetentIdentifierChange(_ sheetPresentationController: UISheetPresentationController) {
-        guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
+        runOnMainSync {
+            guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        if suppressNextDetentDelegateEvent {
-            suppressNextDetentDelegateEvent = false
-            return
-        }
+            if suppressNextDetentDelegateEvent {
+                suppressNextDetentDelegateEvent = false
+                return
+            }
 
-        let nativeDetents = buildNativeDetentIdentifiers()
-        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
-            currentDetentIndex = index
-            onDetentChange(Double(index), .swipe)
+            let nativeDetents = buildNativeDetentIdentifiers()
+            if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
+                currentDetentIndex = index
+                onDetentChange(Double(index), .swipe)
+            }
         }
     }
 
     fileprivate func handlePresentationControllerWillDismiss(_ presentationController: UIPresentationController) {
-        guard let contentVC = sheetViewController?.contentViewController else { return }
-        let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
-        contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        runOnMainSync {
+            guard let contentVC = sheetViewController?.contentViewController else { return }
+            let isInteractiveDismissal = presentationController.presentedViewController.transitionCoordinator?.isInteractive ?? false
+            contentVC.notePresentationWillDismiss(isInteractive: isInteractiveDismissal)
+        }
     }
 
     fileprivate func hostViewDidAttach() {
-        isHostAttached = true
+        runOnMainSync {
+            isHostAttached = true
 
-        if shouldPresentWhenHostAttaches || isOpen {
-            presentSheet()
+            if shouldPresentWhenHostAttaches || isOpenStorage {
+                presentSheet()
+            }
         }
     }
 
     fileprivate func hostViewDidDetach() {
-        isHostAttached = false
-        shouldPresentWhenHostAttaches = false
+        runOnMainSync {
+            isHostAttached = false
+            shouldPresentWhenHostAttaches = false
 
-        // If the host leaves the hierarchy, force a clean teardown.
-        if isCurrentlyPresented {
-            dismissSheet(reason: .system)
+            // If the host leaves the hierarchy, force a clean teardown.
+            if isCurrentlyPresented {
+                dismissSheet(reason: .system)
+            }
         }
     }
 
     func prepareForRecycle() {
-        shouldPresentWhenHostAttaches = false
-        suppressNextDetentDelegateEvent = false
+        runOnMainSync {
+            shouldPresentWhenHostAttaches = false
+            suppressNextDetentDelegateEvent = false
+            isBatchUpdatingProps = false
+            pendingPropUpdates.removeAll()
+            appliedIsOpenState = false
 
-        // Recycled views should not emit callbacks from stale subscriptions.
-        onOpenChange = { _, _ in }
-        onDetentChange = { _, _ in }
-        onWillPresent = {}
-        onDidPresent = {}
-        onWillDismiss = {}
-        onDidDismiss = {}
+            // Recycled views should not emit callbacks from stale subscriptions.
+            onOpenChangeStorage = { _, _ in }
+            onDetentChangeStorage = { _, _ in }
+            onWillPresentStorage = {}
+            onDidPresentStorage = {}
+            onWillDismissStorage = {}
+            onDidDismissStorage = {}
 
-        if let contentVC = sheetViewController?.contentViewController {
-            contentVC.dismissalReasonOverride = .system
-            if contentVC.presentingViewController != nil {
-                contentVC.dismiss(animated: false)
+            if let contentVC = sheetViewController?.contentViewController {
+                contentVC.dismissalReasonOverride = .system
+                if contentVC.presentingViewController != nil {
+                    contentVC.dismiss(animated: false)
+                }
             }
-        }
 
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        currentDetentIndex = 0
-        isHostAttached = view.window != nil
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            currentDetentIndex = 0
+            isHostAttached = view.window != nil
 
-        // Reset public properties to avoid stale configuration on reuse.
-        detents = []
-        initialDetentIndex = 0
-        selectedDetentIndex = -1
-        isOpen = false
-        grabberVisible = true
-        allowSwipeToDismiss = true
-        backgroundInteraction = .first("modal")
-        cornerRadius = -1
-        expandsWhenScrolledToEdge = true
+            // Reset props directly so recycle does not trigger redundant update work.
+            detentsStorage = []
+            initialDetentIndexStorage = 0
+            selectedDetentIndexStorage = -1
+            isOpenStorage = false
+            grabberVisibleStorage = true
+            allowSwipeToDismissStorage = true
+            backgroundInteractionStorage = .first("modal")
+            cornerRadiusStorage = -1
+            expandsWhenScrolledToEdgeStorage = true
+        }
     }
 }
 
@@ -682,14 +950,18 @@
 
 extension HybridRnBottomSheet: SheetPresenterDelegate {
     func sheetWillDismiss(reason: NativeChangeReason) {
-        onWillDismiss()
+        runOnMainSync {
+            onWillDismiss()
+        }
     }
 
     func sheetDidDismiss(reason: NativeChangeReason) {
-        isCurrentlyPresented = false
-        sheetViewController = nil
-        onDidDismiss()
-        onOpenChange(false, reason)
+        runOnMainSync {
+            isCurrentlyPresented = false
+            sheetViewController = nil
+            onDidDismiss()
+            onOpenChange(false, reason)
+        }
     }
 }
 
diff --git a/tasks/todo.md b/tasks/todo.md
index 184d417c03a82511ab462b2fac53fb959842760e..bde7b82021d3a7dc18ba9cf60dea4099a84ca91b
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,11 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `Phase 3 Thread-Safe Prop Updates`: refactored `ios/RnBottomSheet.swift` protocol-facing props/callbacks/methods to marshal reads/writes through a `runOnMainSync` gate, preventing cross-thread mutation of UIKit-bound state.
+  - Added Nitro `beforeUpdate()` / `afterUpdate()` batching in `ios/RnBottomSheet.swift` with staged prop-update coalescing (`pendingPropUpdates`) so batched React prop commits apply deterministically once per transaction.
+  - Updated `IMPLEMENTATION_PLAN.md` stale completion state for already-implemented Phase 2/4/5 medium items and marked the newly delivered Phase 3 thread-safety + batching tasks complete.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, `yarn test`, and successful `yarn workspace rn-bottom-sheet-example ios` build/run.
+  - Maestro MCP gate remains non-blocking for this loop because `specs/001-native-ios-sheet-bindings/spec.md` still sets `E2E Gate State: deferred`.
   - Ralph iteration `Phase 5 HIGH iOS Detent Integration Test Sync`: added `src/__tests__/bottom-sheet.detent.integration.test.tsx` to validate detent presenter prop wiring (native detent config + initial/selected indices), controlled `selectedDetent` updates, and detent event/method bridging (`onDetentChange`, `snapToDetent`, `getCurrentDetentIndex`) through the real `BottomSheet` wrapper.
   - Updated `IMPLEMENTATION_PLAN.md` to mark "Add iOS integration tests for detent behavior" complete.
   - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
@@ -394,9 +399,9 @@
 
 ## Ralph Iteration 2026-02-12 (Phase 3 Thread-Safe Prop Updates)
 
-- [ ] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
-- [ ] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
-- [ ] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
-- [ ] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm highest-priority truly incomplete item is cross-thread prop safety and verify current implementation lacks explicit thread marshaling
+- [x] Implement main-thread marshaling for Nitro prop setters/getters and imperative methods in `ios/RnBottomSheet.swift`
+- [x] Implement `beforeUpdate()` / `afterUpdate()` batching hooks for grouped prop application in `ios/RnBottomSheet.swift`
+- [x] Synchronize stale-complete entries in `IMPLEMENTATION_PLAN.md` based on verified implementation state
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`, `yarn workspace rn-bottom-sheet-example ios`
+- [x] Capture verification outcomes in the Review section

tokens used
195,348
<promise>DONE</promise>
