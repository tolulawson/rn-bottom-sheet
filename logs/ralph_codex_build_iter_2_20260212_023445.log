OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/tolu/Desktop/dev/rn-bottom-sheet
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c516a-e3fc-7bd2-9b02-f9d108a6628f
--------
user
# Ralph Build Mode

Based on Geoffrey Huntley's Ralph Wiggum methodology.

---

## Phase 0: Orient

Read `.specify/memory/constitution.md` to understand project principles and constraints.

---

## Phase 1: Discover Work Items

Search for incomplete work from these sources (in order):

1. **specs/ folder** — Look for `.md` files NOT marked `## Status: COMPLETE`
2. **IMPLEMENTATION_PLAN.md** — If exists, find unchecked `- [ ]` tasks
3. **GitHub Issues** — Check for open issues (if this is a GitHub repo)
4. **Any task tracker** — Jira, Linear, etc. if configured

Pick the **HIGHEST PRIORITY** incomplete item:
- Lower numbers = higher priority (001 before 010)
- `[HIGH]` before `[MEDIUM]` before `[LOW]`
- Bugs/blockers before features

Before implementing, search the codebase to verify it's not already done.

---

## Phase 1b: Re-Verification Mode (No Incomplete Work Found)

**If ALL specs appear complete**, don't just exit — do a quality check:

1. **Randomly pick** one completed spec from `specs/`
2. **Strictly re-verify** ALL its acceptance criteria:
   - Run the actual tests mentioned in the spec
   - Manually verify each criterion is truly met
   - Check edge cases
   - Look for regressions
3. **If any criterion fails**: Unmark the spec as complete and fix it
4. **If all pass**: Output `<promise>DONE</promise>` to confirm quality

This ensures the codebase stays healthy even when "nothing to do."

---

## Phase 2: Implement

Implement the selected spec/task completely:
- Follow the spec's requirements exactly
- Write clean, maintainable code
- Add tests as needed

---

## Phase 3: Validate

Run the project's test suite and verify:
- All tests pass
- No lint errors
- The spec's acceptance criteria are 100% met

---

## Phase 4: Commit & Update

1. Mark the spec/task as complete (add `## Status: COMPLETE` to spec file)
2. `git add -A`
3. `git commit` with a descriptive message
4. `git push`

---

## Completion Signal

**CRITICAL:** Only output the magic phrase when the work is 100% complete.

Check:
- [ ] Implementation matches all requirements
- [ ] All tests pass
- [ ] All acceptance criteria verified
- [ ] Changes committed and pushed
- [ ] Spec marked as complete

**If ALL checks pass, output:** `<promise>DONE</promise>`

**If ANY check fails:** Fix the issue and try again. Do NOT output the magic phrase.

mcp: notion starting
mcp: codex_apps starting
mcp: pencil starting
mcp: linear starting
mcp: figma starting
mcp: context7 starting
mcp: pencil ready
mcp: figma ready
mcp: notion ready
mcp: linear ready
mcp: context7 ready
mcp: codex_apps ready
mcp startup: ready: pencil, figma, notion, linear, context7, codex_apps

thinking
**Planning initial strategy**
codex
I’m going to run the Ralph flow end-to-end: first read the constitution, then discover the highest-priority incomplete work item from specs/plans/issues, verify it isn’t already implemented, and execute through validation and git updates. I’ll start by gathering the current project state and required spec files now.

thinking
**Orchestrating command execution**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && printf '## git status\\n' && git status --short && printf '\\n## top files\\n' && ls -la && printf '\\n## specs files\\n' && rg --files specs | sed 's#"'^#- #'"' && printf '\\n## constitution\\n' && sed -n '1,220p' .specify/memory/constitution.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
## git status
 M ios/RnBottomSheet.swift
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
?? logs/
?? yarn.lock

## top files
total 1168
drwxr-xr-x   46 tolu  staff    1472 Feb 12 02:30 .
drwxr-xr-x@ 108 tolu  staff    3456 Feb 12 02:05 ..
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .claude
drwxr-xr-x    3 tolu  staff      96 Feb 12 02:11 .codex
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .cursor
-rw-r--r--@   1 tolu  staff     283 Feb 12 00:45 .editorconfig
drwxr-xr-x@  14 tolu  staff     448 Feb 12 02:35 .git
-rw-r--r--@   1 tolu  staff      72 Feb 12 00:45 .gitattributes
drwxr-xr-x@   5 tolu  staff     160 Feb 12 00:45 .github
-rw-r--r--@   1 tolu  staff     866 Feb 12 01:45 .gitignore
-rw-r--r--@   1 tolu  staff       9 Feb 12 00:45 .nvmrc

thinking
**Planning commentary update for dirty files**
codex
I’ve read the constitution and confirmed the repo already has unrelated local changes, so I’ll avoid touching those files unless required by the selected task. Next I’m applying the `ralph-wiggum` skill flow to discover the highest-priority incomplete item across specs and implementation plan, then verify it against code before changing anything.

thinking
**Planning to read skill file**
exec
/bin/zsh -lc "sed -n '1,220p' '/Users/tolu/.agents/skills/ralph-wiggum/SKILL.md'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
---
name: ralph-wiggum
description: Autonomous AI coding with spec-driven development. Implements Geoffrey Huntley's iterative bash loop methodology where agents work through specs one at a time, outputting a completion signal only when acceptance criteria are 100% met.
license: MIT
metadata:
  author: fstandhartinger
  version: "1.0"
  repository: https://github.com/fstandhartinger/ralph-wiggum
  website: https://ralph-wiggum.ai
---

# Ralph Wiggum

> Autonomous AI coding with spec-driven development

## What is Ralph Wiggum?

Ralph Wiggum combines **Geoffrey Huntley's iterative bash loop** with **spec-driven development** for fully autonomous AI-assisted software development.

The key insight: **Fresh context each iteration**. Each loop starts a new agent process with a clean context window, preventing context overflow and degradation.

thinking
**Inspecting spec files for task status**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && printf '## Spec status markers\\n' && rg -n \""'^## Status:" specs/**/*.md specs/*.md 2>/dev/null || true && printf '"'\\n## Specs directory listing\\n' && find specs -maxdepth 3 -type f -name '*.md' | sort && printf '\\n## IMPLEMENTATION_PLAN unchecked\\n' && if [ -f IMPLEMENTATION_PLAN.md ]; then rg -n \""'^- '"\\[ \\]\" IMPLEMENTATION_PLAN.md || true; else echo 'IMPLEMENTATION_PLAN.md missing'; fi" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
## Spec status markers
zsh:1: no matches found: specs/*.md

## Specs directory listing
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md
specs/001-native-ios-sheet-bindings/checklists/requirements.md
specs/001-native-ios-sheet-bindings/data-model.md
specs/001-native-ios-sheet-bindings/plan.md
specs/001-native-ios-sheet-bindings/quickstart.md
specs/001-native-ios-sheet-bindings/research.md
specs/001-native-ios-sheet-bindings/spec.md
specs/001-native-ios-sheet-bindings/tasks.md

## IMPLEMENTATION_PLAN unchecked
20:- [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
21:- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
22:- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
23:- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
24:- [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
25:- [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design

thinking
**Planning to inspect spec and tasks**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' IMPLEMENTATION_PLAN.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' specs/001-native-ios-sheet-bindings/spec.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,320p' specs/001-native-ios-sheet-bindings/tasks.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# Implementation Plan

> Auto-generated breakdown of specs into tasks.
> Delete this file to return to working directly from specs.

## Priority Tasks

### Phase 1: API and Nitro Contract

- [x] [HIGH] Define complete TypeScript type model (BottomSheetDetent, BottomSheetChangeReason) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with full public props interface - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with public methods (present, dismiss, snapToDetent, getCurrentDetentIndex) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Define callback prop types (onOpenChange, onDetentChange, lifecycle callbacks) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Regenerate Nitrogen artifacts after contract changes - from tasks/todo.md Phase 1
- [x] [HIGH] Validate typings compile and exports work correctly - from tasks/todo.md Phase 1
- [x] [HIGH] Update src/index.tsx to export all public types - from IMPLEMENTATION_PLAN API Design

### Phase 2: iOS Sheet Engine

- [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
 succeeded in 52ms:
# Feature Specification: Native iOS Sheet Bindings

**Feature Branch**: `001-native-ios-sheet-bindings`  
**Created**: 2026-02-12  
**Status**: Draft  
**Input**: User description: "Build a React Native library that provides native iOS sheet bindings using Nitro Views with React Native children, dynamic detents, React Navigation integration, in-sheet navigation, and Reanimated-compatible APIs."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Present Native Sheet Content (Priority: P1)

As a React Native developer, I can present and dismiss a native-feeling iOS sheet that renders arbitrary React Native child content so that product experiences match Apple sheet behavior.

**Why this priority**: This is the core product value and the minimum viable capability for the package.

**Independent Test**: In an example app, the developer can open/close a sheet and see custom React Native children rendered correctly without writing custom native code.

**Acceptance Scenarios**:

1. **Given** a screen using the library, **When** the developer triggers open state, **Then** a native iOS sheet appears and displays provided child content.
 succeeded in 51ms:
# Tasks: Native iOS Sheet Bindings

**Input**: Design documents from `/Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/`  
**Prerequisites**: plan.md (required), spec.md (required), research.md, data-model.md, contracts/, quickstart.md

**Tests**: Include tests because the specification requires automated verification coverage for API and integration behavior.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (`[US1]`, `[US2]`, `[US3]`)
- Include exact file paths in descriptions

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Prepare feature scaffolding, generated bindings workflow, and test harness entry points.

- [ ] T001 Create feature README entry and scope note in docs/changelog-notes/README.md

thinking
**Planning parallel issue checks**
codex
I found many unchecked items in `IMPLEMENTATION_PLAN.md`; next I’ll still complete source-order discovery by checking specs status markers and open GitHub/task-tracker items, then I’ll select the single highest-priority item and create a concrete `tasks/todo.md` plan before implementation.
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && printf '## spec status lines\\n' && rg -n \"\\*\\*Status\\*\\*|"'^## Status:" specs/001-native-ios-sheet-bindings/spec.md specs/001-native-ios-sheet-bindings/plan.md specs/001-native-ios-sheet-bindings/tasks.md specs/001-native-ios-sheet-bindings/quickstart.md specs/001-native-ios-sheet-bindings/research.md specs/001-native-ios-sheet-bindings/data-model.md specs/001-native-ios-sheet-bindings/checklists/*.md || true' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && printf '## tracker hints\\n' && rg -n \"Linear|Jira|YouTrack|task tracker|issue tracker\" AGENTS.md README.md docs -S || true" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
## spec status lines
specs/001-native-ios-sheet-bindings/spec.md:5:**Status**: Draft  
 succeeded in 50ms:
## tracker hints
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && printf '## gh repo\\n' && gh repo view --json nameWithOwner,isPrivate,defaultBranchRef --jq '.nameWithOwner+\" private=\"+(.isPrivate|tostring)+\" default=\"+.defaultBranchRef.name' && printf '\\n## open gh issues\\n' && gh issue list --state open --limit 50 --json number,title,labels,createdAt --jq '.[] | \"#\"+(.number|tostring)+\" | \"+.title+\" | labels=\"+((.labels|map(.name)|join(\",\")) // \"\")+\" | created=\"+.createdAt'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 906ms:
tolulawson/rn-bottom-sheet private=false default=main

## open gh issues

thinking
**Assessing highest priority incomplete task**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
# Implementation Todo

## Phase 0: Project Memory Bootstrap

- [x] Create `docs/` knowledge base structure
- [x] Add decision-complete implementation plan
- [x] Add reference summaries and source index
- [x] Add ADRs for primary architecture decisions
- [x] Add sync/check scripts for docs integrity

## Phase 1: API and Nitro Contract

- [x] Finalize public TypeScript API and Nitro view contract
- [x] Regenerate Nitrogen artifacts
- [x] Validate typings and exports

## Phase 2: iOS Sheet Engine

- [ ] Implement presenter/controller architecture
- [ ] Map detent model and lifecycle events

thinking
**Prioritizing uncompleted implementation task**
codex
I’m narrowing to the first unchecked `[HIGH]` item in `IMPLEMENTATION_PLAN.md` (`Create SheetPresenterViewController...`) and will verify current code doesn’t already satisfy it before I plan/edit. I’m inspecting the iOS implementation and related JS bridge files now.
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,320p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,320p' src/RnBottomSheet.nitro.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && rg -n \"SheetPresenterViewController|UISheetPresentationController|present\\(|dismiss\\(|selectedDetentIdentifier|sheetPresentationController\" ios src -S" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
/**
 * Nitro View Contract for RnBottomSheet
 *
 * This file defines the native view interface used by Nitrogen to generate
 * the Swift/Kotlin bindings and JavaScript host component configuration.
 *
 * IMPORTANT: Run `yarn nitrogen` after any changes to regenerate bindings.
 */

import type {
  HybridView,
  HybridViewMethods,
  HybridViewProps,
} from 'react-native-nitro-modules';

// =============================================================================
// Detent Types (Native Bridge)
// =============================================================================

/**
 succeeded in 51ms:
import UIKit

/**
 * HybridRnBottomSheet
 *
 * Native iOS implementation of the bottom sheet using UISheetPresentationController.
 * This class conforms to the generated HybridRnBottomSheetSpec protocol from Nitrogen.
 *
 * Key responsibilities:
 * - Present/dismiss native iOS sheets with React Native content
 * - Map detent configurations to UISheetPresentationController.Detent
 * - Handle lifecycle callbacks and state changes
 * - Bridge interaction events back to JavaScript
 */
class HybridRnBottomSheet: HybridRnBottomSheetSpec {

    // =========================================================================
    // MARK: - UIView (required by HybridViewSpec)
    // =========================================================================

 succeeded in 50ms:
ios/RnBottomSheet.swift:6: * Native iOS implementation of the bottom sheet using UISheetPresentationController.
ios/RnBottomSheet.swift:11: * - Map detent configurations to UISheetPresentationController.Detent
ios/RnBottomSheet.swift:34:    private var sheetViewController: SheetPresenterViewController?
ios/RnBottomSheet.swift:116:    func present() {
ios/RnBottomSheet.swift:121:    func dismiss() {
ios/RnBottomSheet.swift:157:        if let sheet = contentVC.sheetPresentationController {
ios/RnBottomSheet.swift:162:        sheetViewController = SheetPresenterViewController(contentViewController: contentVC)
ios/RnBottomSheet.swift:169:        presentingVC.present(contentVC, animated: true) { [weak self] in
ios/RnBottomSheet.swift:182:        contentVC.dismiss(animated: true) { [weak self] in
ios/RnBottomSheet.swift:193:              let sheet = contentVC.sheetPresentationController else {
ios/RnBottomSheet.swift:207:                sheet.selectedDetentIdentifier = targetIdentifier
ios/RnBottomSheet.swift:210:            sheet.selectedDetentIdentifier = targetIdentifier
ios/RnBottomSheet.swift:221:    private func configureSheetController(_ sheet: UISheetPresentationController) {
ios/RnBottomSheet.swift:229:            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
ios/RnBottomSheet.swift:248:    private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
ios/RnBottomSheet.swift:249:        var result: [UISheetPresentationController.Detent] = []
ios/RnBottomSheet.swift:269:                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
ios/RnBottomSheet.swift:278:                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
ios/RnBottomSheet.swift:297:    private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
ios/RnBottomSheet.swift:323:              let sheet = contentVC.sheetPresentationController else {

thinking
**Extending iOS file review**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '321,520p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
        guard isCurrentlyPresented,
              let contentVC = sheetViewController?.contentViewController,
              let sheet = contentVC.sheetPresentationController else {
            return
        }

        sheet.animateChanges {
            sheet.detents = buildNativeDetents()
        }
    }

    private func updateGrabberVisibility() {
        guard isCurrentlyPresented,
              let contentVC = sheetViewController?.contentViewController,
              let sheet = contentVC.sheetPresentationController else {
            return
        }

        sheet.animateChanges {
            sheet.prefersGrabberVisible = grabberVisible
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '520,620p' ios/RnBottomSheet.swift" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 50ms:
        super.viewDidDisappear(animated)
        if isBeingDismissed {
            let reason = isModalInPresentation ? "programmatic" : "swipe"
            presenterDelegate?.sheetDidDismiss(reason: reason)
        }
    }
}

thinking
**Verifying existing presenter implementation**
codex
Verification shows the first unchecked high-priority item appears partially implemented already, so I’m checking the next high-priority items to avoid duplicate work and pick a real gap. I’ll inspect detent normalization/validation coverage (`fit`, ordering, uniqueness) across JS/native now.
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,340p' src/utils/detents.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
/**
 * Detent Normalization and Validation Utilities
 *
 * Handles conversion between JS detent representations and native identifiers,
 * as well as validation of detent configurations.
 */

import type {
  BottomSheetDetent,
  FractionDetent,
  PointsDetent,
  SemanticDetent,
  DetentValidationResult,
} from '../types/bottom-sheet';

// =============================================================================
// Constants
// =============================================================================

const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];

thinking
**Inspecting type definitions**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,320p' src/types/bottom-sheet.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
/**
 * Bottom Sheet Type Definitions
 *
 * Core type definitions for the bottom sheet API.
 * These types are used across the JS and native layers.
 */

// =============================================================================
// Detent Types
// =============================================================================

/**
 * Semantic detent identifiers that map to iOS system detents.
 */
export type SemanticDetent = 'medium' | 'large';

/**
 * Fraction-based detent (0..1 range representing percentage of screen height).
 * Maps to UISheetPresentationController.Detent.custom(identifier:resolver:)
 */

thinking
**Planning detent normalization implementation**
codex
I confirmed there’s a real gap: detent handling doesn’t cover `fit` and native/JS normalization rules are incomplete despite unchecked high-priority plan items. I’m now drafting a focused plan in `tasks/todo.md` for this specific high-priority work item, then I’ll implement and validate it end-to-end.

thinking
**Checking tests for detent coverage**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && rg --files src/__tests__ example/src/__tests__ 2>/dev/null | sort' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
src/__tests__/bottom-sheet.contract.test.ts
src/__tests__/index.test.tsx

thinking
**Planning detent feature implementation**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' src/components/BottomSheetNativeView.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,340p' src/components/BottomSheet.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' src/index.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheet exited 1 in 51ms:
sed: src/components/BottomSheetNativeView.tsx: No such file or directory
 exited 1 in 51ms:
sed: src/components/BottomSheet.tsx: No such file or directory
 succeeded in 52ms:
/**
 * rn-bottom-sheet
 *
 * Native iOS sheet bindings for React Native using Nitro Views.
 */

import { getHostComponent } from 'react-native-nitro-modules';
const RnBottomSheetConfig = require('../nitrogen/generated/shared/json/RnBottomSheetConfig.json');
import type {
  RnBottomSheetMethods,
  RnBottomSheetProps,
} from './RnBottomSheet.nitro';

// =============================================================================
// Native View (internal)
// =============================================================================

/**
 * Internal native view component.
 * Use BottomSheet component for the public API.

thinking
**Assessing project structure**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && find src -maxdepth 3 -type f | sort' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
src/RnBottomSheet.nitro.ts
src/__tests__/bottom-sheet.contract.test.ts
src/__tests__/index.test.tsx
src/index.tsx
src/platform/fallback.ts
src/types/bottom-sheet.ts
src/utils/detents.ts

thinking
**Planning detent normalization implementation**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
@@ -76 +76,10 @@
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Confirming plan and preparing to start**
codex
Plan written to `tasks/todo.md` with concrete checkboxes for this iteration. I’m now implementing against the documented detent contract, starting by reading the project docs/spec references to match the expected `fit/medium/large/fraction/points` behavior and validation rules exactly.
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,320p' specs/001-native-ios-sheet-bindings/contracts/bottom-sheet-api.yaml" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,280p' docs/reference/ios-sheet-apis.md 2>/dev/null || true" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && rg -n "fit|detent|validation|low-to-high|unique|identifier" docs specs IMPLEMENTATION_PLAN.md -S' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:

 succeeded in 52ms:
contract: bottom-sheet-component
version: 1

component:
  name: BottomSheet
  props:
    isOpen:
      type: boolean
      required: false
    defaultOpen:
      type: boolean
      required: false
    detents:
      type: array
      items: detent
      required: false
    initialDetent:
      type: integer_or_last
      required: false
    selectedDetent:
 succeeded in 51ms:
specs/001-native-ios-sheet-bindings/spec.md:6:**Input**: User description: "Build a React Native library that provides native iOS sheet bindings using Nitro Views with React Native children, dynamic detents, React Navigation integration, in-sheet navigation, and Reanimated-compatible APIs."
specs/001-native-ios-sheet-bindings/spec.md:26:### User Story 2 - Configure Detents and Sheet Behavior (Priority: P1)
specs/001-native-ios-sheet-bindings/spec.md:28:As a developer, I can configure sheet sizing and interaction behavior (including dynamic detents) so that sheet motion and resting states match product requirements.
specs/001-native-ios-sheet-bindings/spec.md:30:**Why this priority**: Detent and behavior configuration is essential to achieve native quality and practical adoption.
specs/001-native-ios-sheet-bindings/spec.md:32:**Independent Test**: In isolation, the developer can set multiple detents and observe deterministic initial/resting behavior and state change callbacks.
specs/001-native-ios-sheet-bindings/spec.md:36:1. **Given** a sheet configured with multiple detents, **When** the sheet is opened, **Then** it starts at the configured initial detent.
specs/001-native-ios-sheet-bindings/spec.md:37:2. **Given** a visible sheet with multiple detents, **When** user drag or programmatic snap occurs, **Then** the sheet moves to a valid detent and reports the new detent.
specs/001-native-ios-sheet-bindings/spec.md:38:3. **Given** invalid detent input, **When** configuration is parsed, **Then** the system rejects configuration with a clear developer-facing error.
specs/001-native-ios-sheet-bindings/spec.md:44:As a developer, I can integrate sheet flows with React Navigation and use supported Reanimated patterns so that sheet-based journeys fit existing app architecture.
specs/001-native-ios-sheet-bindings/spec.md:60:- What happens when a detent list is empty, unsorted, duplicated, or out of valid range?
specs/001-native-ios-sheet-bindings/spec.md:72:- **FR-002**: System MUST allow imperative sheet control through a stable reference API (including present, dismiss, and detent snap actions).
specs/001-native-ios-sheet-bindings/spec.md:74:- **FR-004**: System MUST support configurable sheet detents including semantic options and numeric sizing variants.
specs/001-native-ios-sheet-bindings/spec.md:77:- **FR-007**: System MUST emit detent change callbacks when detent selection changes.
specs/001-native-ios-sheet-bindings/spec.md:84:- **FR-014**: System MUST include an example app demonstrating core usage, detent configuration, navigation integration, and animation interoperability.
specs/001-native-ios-sheet-bindings/spec.md:89:- **Sheet Configuration**: Represents declared sheet behavior inputs such as detents, interaction modes, lifecycle callbacks, and control mode.
specs/001-native-ios-sheet-bindings/spec.md:90:- **Sheet Session**: Represents a concrete runtime presentation instance, including open/closed state, active detent index, and lifecycle event state.
specs/001-native-ios-sheet-bindings/spec.md:91:- **Detent Definition**: Represents a single allowable resting height option and its validation rules.
specs/001-native-ios-sheet-bindings/spec.md:99:- **SC-002**: In validation scenarios, 100% of configured valid detents resolve predictably, and 100% of invalid detent configurations fail with explicit errors.
specs/001-native-ios-sheet-bindings/spec.md:100:- **SC-003**: In example app test runs, primary user flows (open, dismiss, detent change, in-sheet navigation) complete successfully in at least 95% of runs without manual recovery.
IMPLEMENTATION_PLAN.md:10:- [x] [HIGH] Define complete TypeScript type model (BottomSheetDetent, BottomSheetChangeReason) - from IMPLEMENTATION_PLAN API Design
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Correcting docs path and inspecting data model**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,240p' docs/references/ios-sheet-apis.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,220p' specs/001-native-ios-sheet-bindings/data-model.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,220p' docs/implementation-plan-v1.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# iOS Sheet API Notes (UIKit)

## Why It Matters

`UISheetPresentationController` is the chosen v1 sheet engine, so all behavior maps to this API.

## Core API Surface

1. `detents`: set available resting heights; order must be low-to-high.
2. `selectedDetentIdentifier`: current selected detent.
3. `largestUndimmedDetentIdentifier`: largest undimmed detent for nonmodal interaction windows.
4. `prefersGrabberVisible`: toggles top grabber affordance.
5. `prefersScrollingExpandsWhenScrolledToEdge`: controls scroll-to-expand behavior.
6. `animateChanges(_:)`: atomic animated mutation of sheet properties.

## Behavioral Notes

1. Default interaction is modal unless undimmed behavior is configured.
2. Detent changes should be batched in `animateChanges` where possible.
3. Keyboard/system layout changes can affect effective presented size.
 succeeded in 51ms:
# Native iOS Sheet Library Plan (v1)

## Summary

Build an iOS-first React Native library that presents native iOS sheets using `UISheetPresentationController` via Nitro Views, supports arbitrary React Native children in sheet content, provides optional React Navigation adapters, defines a constrained Reanimated interop contract, and maintains a living in-repo knowledge base.

## Scope

1. Ship v1 for iOS 16+ on RN 0.81+ with New Architecture/Fabric.
2. Expose controlled + imperative API surface.
3. Support semantic and numeric detents with runtime changes.
4. Support arbitrary React Native child content in the sheet.
5. Support single active sheet globally in v1.
6. Provide optional React Navigation integration package.
7. Provide curated documentation and architecture records in `docs/`.
8. Enforce verification with unit, iOS integration, and Maestro happy-path E2E.

## Non-Goals

1. Android native parity in v1.
 succeeded in 52ms:
# Data Model: Native iOS Sheet Bindings

## Entity: BottomSheetConfiguration

- Purpose: Declares runtime behavior and interaction settings for one sheet instance.
- Fields:
  - `isOpen` (boolean, optional, controlled state)
  - `defaultOpen` (boolean, optional, uncontrolled initial state)
  - `detents` (list of `DetentDefinition`)
  - `initialDetent` (index or `last`)
  - `selectedDetent` (index, optional controlled detent)
  - `grabberVisible` (boolean)
  - `allowSwipeToDismiss` (boolean)
  - `backgroundInteractionMode` (`modal` or threshold mode)
- Validation Rules:
  - Detent list must be non-empty when provided.
  - Detent values must be valid and sortable.
  - Detent indexes must resolve to an existing detent.

## Entity: DetentDefinition
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning optional ID integration**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,220p' src/__tests__/index.test.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,260p' src/__tests__/bottom-sheet.contract.test.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && cat package.json' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
it.todo('write a test');
 succeeded in 51ms:
/**
 * Contract tests for bottom sheet API behavior
 *
 * These tests validate the public API contract without requiring
 * the native implementation. They focus on:
 * - Type definitions and exports
 * - Validation logic
 * - Error handling
 */

describe('BottomSheet Contract', () => {
  describe('Type Exports', () => {
    it.todo('should export BottomSheetDetent type');
    it.todo('should export BottomSheetProps type');
    it.todo('should export BottomSheetMethods type');
    it.todo('should export BottomSheetChangeReason type');
  });

  describe('Detent Validation', () => {
    it.todo('should accept valid semantic detents (medium, large)');
 succeeded in 51ms:
{
  "name": "rn-bottom-sheet",
  "version": "0.1.0",
  "description": "Native bindings to SwiftUI sheet",
  "main": "./lib/module/index.js",
  "types": "./lib/typescript/src/index.d.ts",
  "exports": {
    ".": {
      "source": "./src/index.tsx",
      "types": "./lib/typescript/src/index.d.ts",
      "default": "./lib/module/index.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "lib",
    "android",
    "ios",
    "cpp",
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning detent fit handling**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && rg -n \"\\bfit\\b\" docs specs src ios -S" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
docs/implementation-plan-v1.md:57:- `BottomSheetDetent = 'fit' | 'medium' | 'large' | { type: 'fraction'; value: number; id?: string } | { type: 'points'; value: number; id?: string }`
specs/001-native-ios-sheet-bindings/spec.md:44:As a developer, I can integrate sheet flows with React Navigation and use supported Reanimated patterns so that sheet-based journeys fit existing app architecture.
specs/001-native-ios-sheet-bindings/data-model.md:24:  - `fit`
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Designing fit detent and validation**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && rg -n "detentsToNativeConfig|detentToNativeIdentifier|validateDetents|normalizeDetents" src example ios -S' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
src/index.tsx:63:  validateDetents,
src/index.tsx:65:  normalizeDetents,
src/index.tsx:73:  detentToNativeIdentifier,
src/index.tsx:74:  detentsToNativeConfig,
src/utils/detents.ts:104:export function validateDetents(
src/utils/detents.ts:132:  const normalized = normalizeDetents(detents);
src/utils/detents.ts:189:export function normalizeDetents(
src/utils/detents.ts:216:export function detentToNativeIdentifier(
src/utils/detents.ts:238:export function detentsToNativeConfig(
src/utils/detents.ts:241:  const normalized = normalizeDetents(detents);
src/utils/detents.ts:243:    identifier: detentToNativeIdentifier(detent, index),
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning detent type updates**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/types/bottom-sheet.ts
@@ -14,3 +14,3 @@
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
@@ -23,2 +23,3 @@
   value: number; // 0..1
+  id?: string;
 }
@@ -32,2 +33,3 @@
   value: number; // > 0
+  id?: string;
 }
@@ -36,2 +38,3 @@
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/types/bottom-sheet.ts
file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Redesigning and rewiring utils for detents**
codex
I’ve finished spec alignment and I’m now editing the detent model implementation itself (`types` + `utils`) to add `fit`, enforce deterministic identifier rules, and normalize/sort consistently. After that I’ll patch the iOS detent mapper to consume the same semantics.
file update
D /Users/tolu/Desktop/dev/rn-bottom-sheet/src/utils/detents.ts
/**
 * Detent Normalization and Validation Utilities
 *
 * Handles conversion between JS detent representations and native identifiers,
 * as well as validation of detent configurations.
 */

import type {
  BottomSheetDetent,
  FractionDetent,
  PointsDetent,
  SemanticDetent,
  DetentValidationResult,
} from '../types/bottom-sheet';

// =============================================================================
// Constants
// =============================================================================

const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];

/**
 * Approximate height values for semantic detents (used for sorting).
 * These are relative values, not actual pixel values.
 */
const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
  medium: 0.5,
  large: 1.0,
};

// =============================================================================
// Type Guards
// =============================================================================

export function isSemanticDetent(
  detent: BottomSheetDetent
): detent is SemanticDetent {
  return (
    typeof detent === 'string' &&
    SEMANTIC_DETENTS.includes(detent as SemanticDetent)
  );
}

export function isFractionDetent(
  detent: BottomSheetDetent
): detent is FractionDetent {
  return (
    typeof detent === 'object' &&
    detent !== null &&
    'type' in detent &&
    detent.type === 'fraction'
  );
}

export function isPointsDetent(
  detent: BottomSheetDetent
): detent is PointsDetent {
  return (
    typeof detent === 'object' &&
    detent !== null &&
    'type' in detent &&
    detent.type === 'points'
  );
}

// =============================================================================
// Validation
// =============================================================================

/**
 * Validate a single detent value.
 */
export function validateDetent(detent: BottomSheetDetent): string | null {
  if (isSemanticDetent(detent)) {
    return null; // Valid
  }

  if (isFractionDetent(detent)) {
    if (typeof detent.value !== 'number') {
      return `Fraction detent value must be a number, got ${typeof detent.value}`;
    }
    if (detent.value < 0 || detent.value > 1) {
      return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
    }
    return null;
  }

  if (isPointsDetent(detent)) {
    if (typeof detent.value !== 'number') {
      return `Points detent value must be a number, got ${typeof detent.value}`;
    }
    if (detent.value <= 0) {
      return `Points detent value must be positive, got ${detent.value}`;
    }
    return null;
  }

  return `Invalid detent type: ${JSON.stringify(detent)}`;
}

/**
 * Validate an array of detents.
 */
export function validateDetents(
  detents: BottomSheetDetent[]
): DetentValidationResult {
  if (!Array.isArray(detents)) {
    return {
      valid: false,
      error: 'Detents must be an array',
    };
  }

  if (detents.length === 0) {
    return {
      valid: false,
      error: 'Detents array cannot be empty',
    };
  }

  for (let i = 0; i < detents.length; i++) {
    const detent = detents[i]!;
    const error = validateDetent(detent);
    if (error) {
      return {
        valid: false,
        error: `Invalid detent at index ${i}: ${error}`,
      };
    }
  }

  const normalized = normalizeDetents(detents);

  return {
    valid: true,
    normalizedDetents: normalized,
  };
}

// =============================================================================
// Normalization
// =============================================================================

/**
 * Get a comparable height value for a detent (used for sorting).
 * For semantic and fraction detents, returns a 0..1 value.
 * For points detents, returns a large value to sort them based on points.
 */
export function getDetentSortValue(detent: BottomSheetDetent): number {
  if (isSemanticDetent(detent)) {
    return SEMANTIC_HEIGHT_VALUES[detent];
  }

  if (isFractionDetent(detent)) {
    return detent.value;
  }

  if (isPointsDetent(detent)) {
    // For points, we assume a reference height of 1000 for sorting purposes
    // This allows points to be compared relatively with fractions
    return detent.value / 1000;
  }

  return 0;
}

/**
 * Generate a unique identifier for a detent (used for deduplication).
 */
export function getDetentIdentifier(detent: BottomSheetDetent): string {
  if (isSemanticDetent(detent)) {
    return `semantic:${detent}`;
  }

  if (isFractionDetent(detent)) {
    return `fraction:${detent.value}`;
  }

  if (isPointsDetent(detent)) {
    return `points:${detent.value}`;
  }

  return 'unknown';
}

/**
 * Normalize detents: sort low-to-high and deduplicate.
 */
export function normalizeDetents(
  detents: BottomSheetDetent[]
): BottomSheetDetent[] {
  // Deduplicate by identifier
  const seen = new Set<string>();
  const unique: BottomSheetDetent[] = [];

  for (const detent of detents) {
    const id = getDetentIdentifier(detent);
    if (!seen.has(id)) {
      seen.add(id);
      unique.push(detent);
    }
  }

  // Sort by height value (low to high)
  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
}

// =============================================================================
// Native Identifier Mapping
// =============================================================================

/**
 * Convert a detent to its native iOS identifier.
 * Used for bridging to UISheetPresentationController.
 */
export function detentToNativeIdentifier(
  detent: BottomSheetDetent,
  index: number
): string {
  if (isSemanticDetent(detent)) {
    return detent; // 'medium' or 'large' map directly
  }

  if (isFractionDetent(detent)) {
    return `fraction_${detent.value}_${index}`;
  }

  if (isPointsDetent(detent)) {
    return `points_${detent.value}_${index}`;
  }

  return `custom_${index}`;
}

/**
 * Convert an array of detents to native identifier mapping.
 */
export function detentsToNativeConfig(
  detents: BottomSheetDetent[]
): Array<{ identifier: string; detent: BottomSheetDetent }> {
  const normalized = normalizeDetents(detents);
  return normalized.map((detent, index) => ({
    identifier: detentToNativeIdentifier(detent, index),
    detent,
  }));
}

// =============================================================================
// Default Values
// =============================================================================

/**
 * Default detents if none are specified.
 */
export const DEFAULT_DETENTS: BottomSheetDetent[] = ['medium', 'large'];

/**
 * Get detents with defaults applied.
 */
export function getDetentsWithDefaults(
  detents: BottomSheetDetent[] | undefined
): BottomSheetDetent[] {
  if (!detents || detents.length === 0) {
    return DEFAULT_DETENTS;
  }
  return detents;
}
apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
D /Users/tolu/Desktop/dev/rn-bottom-sheet/src/utils/detents.ts
file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
deleted file mode 100644
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..0000000000000000000000000000000000000000
--- a/src/utils/detents.ts
+++ /dev/null
@@ -1,267 +0,0 @@
-/**
- * Detent Normalization and Validation Utilities
- *
- * Handles conversion between JS detent representations and native identifiers,
- * as well as validation of detent configurations.
- */
-
-import type {
-  BottomSheetDetent,
-  FractionDetent,
-  PointsDetent,
-  SemanticDetent,
-  DetentValidationResult,
-} from '../types/bottom-sheet';
-
-// =============================================================================
-// Constants
-// =============================================================================
-
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
-
-/**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
- */
-const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
-  medium: 0.5,
-  large: 1.0,
-};
-
-// =============================================================================
-// Type Guards
-// =============================================================================
-
-export function isSemanticDetent(
-  detent: BottomSheetDetent
-): detent is SemanticDetent {
-  return (
-    typeof detent === 'string' &&
-    SEMANTIC_DETENTS.includes(detent as SemanticDetent)
-  );
-}
-
-export function isFractionDetent(
-  detent: BottomSheetDetent
-): detent is FractionDetent {
-  return (
-    typeof detent === 'object' &&
-    detent !== null &&
-    'type' in detent &&
-    detent.type === 'fraction'
-  );
-}
-
-export function isPointsDetent(
-  detent: BottomSheetDetent
-): detent is PointsDetent {
-  return (
-    typeof detent === 'object' &&
-    detent !== null &&
-    'type' in detent &&
-    detent.type === 'points'
-  );
-}
-
-// =============================================================================
-// Validation
-// =============================================================================
-
-/**
- * Validate a single detent value.
- */
-export function validateDetent(detent: BottomSheetDetent): string | null {
-  if (isSemanticDetent(detent)) {
-    return null; // Valid
-  }
-
-  if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
-    }
-    if (detent.value < 0 || detent.value > 1) {
-      return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
-    }
-    return null;
-  }
-
-  if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
-    }
-    if (detent.value <= 0) {
-      return `Points detent value must be positive, got ${detent.value}`;
-    }
-    return null;
-  }
-
-  return `Invalid detent type: ${JSON.stringify(detent)}`;
-}
-
-/**
- * Validate an array of detents.
- */
-export function validateDetents(
-  detents: BottomSheetDetent[]
-): DetentValidationResult {
-  if (!Array.isArray(detents)) {
-    return {
-      valid: false,
-      error: 'Detents must be an array',
-    };
-  }
-
-  if (detents.length === 0) {
-    return {
-      valid: false,
-      error: 'Detents array cannot be empty',
-    };
-  }
-
-  for (let i = 0; i < detents.length; i++) {
-    const detent = detents[i]!;
-    const error = validateDetent(detent);
-    if (error) {
-      return {
-        valid: false,
-        error: `Invalid detent at index ${i}: ${error}`,
-      };
-    }
-  }
-
-  const normalized = normalizeDetents(detents);
-
-  return {
-    valid: true,
-    normalizedDetents: normalized,
-  };
-}
-
-// =============================================================================
-// Normalization
-// =============================================================================
-
-/**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
- */
-export function getDetentSortValue(detent: BottomSheetDetent): number {
-  if (isSemanticDetent(detent)) {
-    return SEMANTIC_HEIGHT_VALUES[detent];
-  }
-
-  if (isFractionDetent(detent)) {
-    return detent.value;
-  }
-
-  if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
-  }
-
-  return 0;
-}
-
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
-  if (isSemanticDetent(detent)) {
-    return `semantic:${detent}`;
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction:${detent.value}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points:${detent.value}`;
-  }
-
-  return 'unknown';
-}
-
-/**
- * Normalize detents: sort low-to-high and deduplicate.
- */
-export function normalizeDetents(
-  detents: BottomSheetDetent[]
-): BottomSheetDetent[] {
-  // Deduplicate by identifier
-  const seen = new Set<string>();
-  const unique: BottomSheetDetent[] = [];
-
-  for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
-      unique.push(detent);
-    }
-  }
-
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
-}
-
-// =============================================================================
-// Native Identifier Mapping
-// =============================================================================
-
-/**
- * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
- */
-export function detentToNativeIdentifier(
-  detent: BottomSheetDetent,
-  index: number
-): string {
-  if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
-  }
-
-  return `custom_${index}`;
-}
-
-/**
- * Convert an array of detents to native identifier mapping.
- */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
-  const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
-}
-
-// =============================================================================
-// Default Values
-// =============================================================================
-
-/**
- * Default detents if none are specified.
- */
-export const DEFAULT_DETENTS: BottomSheetDetent[] = ['medium', 'large'];
-
-/**
- * Get detents with defaults applied.
- */
-export function getDetentsWithDefaults(
-  detents: BottomSheetDetent[] | undefined
-): BottomSheetDetent[] {
-  if (!detents || detents.length === 0) {
-    return DEFAULT_DETENTS;
-  }
-  return detents;
-}
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
deleted file mode 100644
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..0000000000000000000000000000000000000000
--- a/src/utils/detents.ts
+++ /dev/null
@@ -1,267 +0,0 @@
-/**
- * Detent Normalization and Validation Utilities
- *
- * Handles conversion between JS detent representations and native identifiers,
- * as well as validation of detent configurations.
- */
-
-import type {
-  BottomSheetDetent,
-  FractionDetent,
-  PointsDetent,
-  SemanticDetent,
-  DetentValidationResult,
-} from '../types/bottom-sheet';
-
-// =============================================================================
-// Constants
-// =============================================================================
-
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
-
-/**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
- */
-const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
-  medium: 0.5,
-  large: 1.0,
-};
-
-// =============================================================================
-// Type Guards
-// =============================================================================
-
-export function isSemanticDetent(
-  detent: BottomSheetDetent
-): detent is SemanticDetent {
-  return (
-    typeof detent === 'string' &&
-    SEMANTIC_DETENTS.includes(detent as SemanticDetent)
-  );
-}
-
-export function isFractionDetent(
-  detent: BottomSheetDetent
-): detent is FractionDetent {
-  return (
-    typeof detent === 'object' &&
-    detent !== null &&
-    'type' in detent &&
-    detent.type === 'fraction'
-  );
-}
-
-export function isPointsDetent(
-  detent: BottomSheetDetent
-): detent is PointsDetent {
-  return (
-    typeof detent === 'object' &&
-    detent !== null &&
-    'type' in detent &&
-    detent.type === 'points'
-  );
-}
-
-// =============================================================================
-// Validation
-// =============================================================================
-
-/**
- * Validate a single detent value.
- */
-export function validateDetent(detent: BottomSheetDetent): string | null {
-  if (isSemanticDetent(detent)) {
-    return null; // Valid
-  }
-
-  if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
-    }
-    if (detent.value < 0 || detent.value > 1) {
-      return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
-    }
-    return null;
-  }
-
-  if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
-    }
-    if (detent.value <= 0) {
-      return `Points detent value must be positive, got ${detent.value}`;
-    }
-    return null;
-  }
-
-  return `Invalid detent type: ${JSON.stringify(detent)}`;
-}
-
-/**
- * Validate an array of detents.
- */
-export function validateDetents(
-  detents: BottomSheetDetent[]
-): DetentValidationResult {
-  if (!Array.isArray(detents)) {
-    return {
-      valid: false,
-      error: 'Detents must be an array',
-    };
-  }
-
-  if (detents.length === 0) {
-    return {
-      valid: false,
-      error: 'Detents array cannot be empty',
-    };
-  }
-
-  for (let i = 0; i < detents.length; i++) {
-    const detent = detents[i]!;
-    const error = validateDetent(detent);
-    if (error) {
-      return {
-        valid: false,
-        error: `Invalid detent at index ${i}: ${error}`,
-      };
-    }
-  }
-
-  const normalized = normalizeDetents(detents);
-
-  return {
-    valid: true,
-    normalizedDetents: normalized,
-  };
-}
-
-// =============================================================================
-// Normalization
-// =============================================================================
-
-/**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
- */
-export function getDetentSortValue(detent: BottomSheetDetent): number {
-  if (isSemanticDetent(detent)) {
-    return SEMANTIC_HEIGHT_VALUES[detent];
-  }
-
-  if (isFractionDetent(detent)) {
-    return detent.value;
-  }
-
-  if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
-  }
-
-  return 0;
-}
-
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
-  if (isSemanticDetent(detent)) {
-    return `semantic:${detent}`;
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction:${detent.value}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points:${detent.value}`;
-  }
-
-  return 'unknown';
-}
-
-/**
- * Normalize detents: sort low-to-high and deduplicate.
- */
-export function normalizeDetents(
-  detents: BottomSheetDetent[]
-): BottomSheetDetent[] {
-  // Deduplicate by identifier
-  const seen = new Set<string>();
-  const unique: BottomSheetDetent[] = [];
-
-  for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
-      unique.push(detent);
-    }
-  }
-
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
-}
-
-// =============================================================================
-// Native Identifier Mapping
-// =============================================================================
-
-/**
- * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
- */
-export function detentToNativeIdentifier(
-  detent: BottomSheetDetent,
-  index: number
-): string {
-  if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
-  }
-
-  return `custom_${index}`;
-}
-
-/**
- * Convert an array of detents to native identifier mapping.
- */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
-  const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
-}
-
-// =============================================================================
-// Default Values
-// =============================================================================
-
-/**
- * Default detents if none are specified.
- */
-export const DEFAULT_DETENTS: BottomSheetDetent[] = ['medium', 'large'];
-
-/**
- * Get detents with defaults applied.
- */
-export function getDetentsWithDefaults(
-  detents: BottomSheetDetent[] | undefined
-): BottomSheetDetent[] {
-  if (!detents || detents.length === 0) {
-    return DEFAULT_DETENTS;
-  }
-  return detents;
-}
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/utils/detents.ts
/**
 * Detent Normalization and Validation Utilities
 *
 * Handles conversion between JS detent representations and native identifiers,
 * as well as validation of detent configurations.
 */

import type {
  BottomSheetDetent,
  FractionDetent,
  PointsDetent,
  SemanticDetent,
  DetentValidationResult,
} from '../types/bottom-sheet';

// =============================================================================
// Constants
// =============================================================================

const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];

/**
 * Approximate relative height values for semantic detents (used for sorting).
 */
const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
  fit: 0.25,
  medium: 0.5,
  large: 1.0,
};

const POINTS_REFERENCE_HEIGHT = 1000;

// =============================================================================
// Type Guards
// =============================================================================

export function isSemanticDetent(
  detent: BottomSheetDetent
): detent is SemanticDetent {
  return (
    typeof detent === 'string' &&
    SEMANTIC_DETENTS.includes(detent as SemanticDetent)
  );
}

export function isFractionDetent(
  detent: BottomSheetDetent
): detent is FractionDetent {
  return (
    typeof detent === 'object' &&
    detent !== null &&
    'type' in detent &&
    detent.type === 'fraction'
  );
}

export function isPointsDetent(
  detent: BottomSheetDetent
): detent is PointsDetent {
  return (
    typeof detent === 'object' &&
    detent !== null &&
    'type' in detent &&
    detent.type === 'points'
  );
}

// =============================================================================
// Validation
// =============================================================================

function validateCustomId(id: unknown): string | null {
  if (id === undefined) {
    return null;
  }
  if (typeof id !== 'string') {
    return `Detent id must be a string when provided, got ${typeof id}`;
  }
  if (id.trim().length === 0) {
    return 'Detent id must not be empty';
  }
  return null;
}

/**
 * Validate a single detent value.
 */
export function validateDetent(detent: BottomSheetDetent): string | null {
  if (isSemanticDetent(detent)) {
    return null;
  }

  if (isFractionDetent(detent)) {
    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
    }
    if (detent.value < 0 || detent.value > 1) {
      return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
    }
    return validateCustomId(detent.id);
  }

  if (isPointsDetent(detent)) {
    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
      return `Points detent value must be a finite number, got ${String(detent.value)}`;
    }
    if (detent.value <= 0) {
      return `Points detent value must be positive, got ${detent.value}`;
    }
    return validateCustomId(detent.id);
  }

  return `Invalid detent type: ${JSON.stringify(detent)}`;
}

function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
}

/**
 * Validate an array of detents.
 */
export function validateDetents(
  detents: BottomSheetDetent[]
): DetentValidationResult {
  if (!Array.isArray(detents)) {
    return {
      valid: false,
      error: 'Detents must be an array',
    };
  }

  if (detents.length === 0) {
    return {
      valid: false,
      error: 'Detents array cannot be empty',
    };
  }

  const customIds = new Set<string>();

  for (let i = 0; i < detents.length; i++) {
    const detent = detents[i]!;
    const error = validateDetent(detent);
    if (error) {
      return {
        valid: false,
        error: `Invalid detent at index ${i}: ${error}`,
      };
    }

    if (isFractionDetent(detent) || isPointsDetent(detent)) {
      const customId = getCustomDetentId(detent);
      if (customId) {
        if (customIds.has(customId)) {
          return {
            valid: false,
            error: `Duplicate detent id '${customId}' is not allowed`,
          };
        }
        customIds.add(customId);
      }
    }
  }

  return {
    valid: true,
    normalizedDetents: normalizeDetents(detents),
  };
}

// =============================================================================
// Normalization
// =============================================================================

/**
 * Get a comparable height value for a detent (used for low-to-high sorting).
 */
export function getDetentSortValue(detent: BottomSheetDetent): number {
  if (isSemanticDetent(detent)) {
    return SEMANTIC_HEIGHT_VALUES[detent];
  }

  if (isFractionDetent(detent)) {
    return detent.value;
  }

  if (isPointsDetent(detent)) {
    return detent.value / POINTS_REFERENCE_HEIGHT;
  }

  return 0;
}

function getResolvedDetentKey(detent: BottomSheetDetent): string {
  if (isSemanticDetent(detent)) {
    return `semantic:${detent}`;
  }

  if (isFractionDetent(detent)) {
    return `fraction:${detent.value}`;
  }

  if (isPointsDetent(detent)) {
    return `points:${detent.value}`;
  }

  return 'unknown';
}

/**
 * Generate a deterministic identifier for a detent.
 */
export function getDetentIdentifier(detent: BottomSheetDetent): string {
  if (isFractionDetent(detent) || isPointsDetent(detent)) {
    const customId = getCustomDetentId(detent);
    if (customId) {
      return `${detent.type}:${customId}`;
    }
  }
  return getResolvedDetentKey(detent);
}

/**
 * Normalize detents by deduplicating resolved values and sorting low-to-high.
 */
export function normalizeDetents(
  detents: BottomSheetDetent[]
): BottomSheetDetent[] {
  const seen = new Set<string>();
  const unique: BottomSheetDetent[] = [];

  for (const detent of detents) {
    const key = getResolvedDetentKey(detent);
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(detent);
    }
  }

  return unique.sort((a, b) => {
    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
    if (valueDiff !== 0) {
      return valueDiff;
    }
    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
  });
}

// =============================================================================
// Native Identifier Mapping
// =============================================================================

function sanitizeIdentifier(value: string): string {
  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
}

/**
 * Convert a detent to its native iOS identifier.
 */
export function detentToNativeIdentifier(
  detent: BottomSheetDetent,
  index: number
): string {
  if (isSemanticDetent(detent)) {
    return detent;
  }

  if (isFractionDetent(detent) || isPointsDetent(detent)) {
    const customId = getCustomDetentId(detent);
    if (customId) {
      return sanitizeIdentifier(customId);
    }
    return `${detent.type}_${detent.value}_${index}`;
  }

  return `custom_${index}`;
}

/**
 * Convert detents to native bridge config objects.
 */
export function detentsToNativeConfig(
  detents: BottomSheetDetent[]
): Array<{
  type: 'semantic' | 'fraction' | 'points';
  value: string | number;
  identifier: string;
  detent: BottomSheetDetent;
}> {
  const normalized = normalizeDetents(detents);
  return normalized.map((detent, index) => {
    if (isSemanticDetent(detent)) {
      return {
        type: 'semantic',
        value: detent,
        identifier: detentToNativeIdentifier(detent, index),
        detent,
      };
    }

    if (isFractionDetent(detent)) {
      return {
        type: 'fraction',
        value: detent.value,
        identifier: detentToNativeIdentifier(detent, index),
        detent,
      };
    }

    return {
      type: 'points',
      value: detent.value,
      identifier: detentToNativeIdentifier(detent, index),
      detent,
    };
  });
}

// =============================================================================
// Default Values
// =============================================================================

/**
 * Default detents if none are specified.
 */
export const DEFAULT_DETENTS: BottomSheetDetent[] = ['medium', 'large'];

/**
 * Get detents with defaults applied.
 */
export function getDetentsWithDefaults(
  detents: BottomSheetDetent[] | undefined
): BottomSheetDetent[] {
  if (!detents || detents.length === 0) {
    return DEFAULT_DETENTS;
  }
  return detents;
}
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/utils/detents.ts
file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Refining Nitro comments semantics**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/RnBottomSheet.nitro.ts
@@ -28,3 +28,3 @@
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/RnBottomSheet.nitro.ts
file update:
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Preparing iOS file inspection**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && nl -ba ios/RnBottomSheet.swift | sed -n '1,260p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
     1	import UIKit
     2	
     3	/**
     4	 * HybridRnBottomSheet
     5	 *
     6	 * Native iOS implementation of the bottom sheet using UISheetPresentationController.
     7	 * This class conforms to the generated HybridRnBottomSheetSpec protocol from Nitrogen.
     8	 *
     9	 * Key responsibilities:
    10	 * - Present/dismiss native iOS sheets with React Native content
    11	 * - Map detent configurations to UISheetPresentationController.Detent
    12	 * - Handle lifecycle callbacks and state changes
    13	 * - Bridge interaction events back to JavaScript
    14	 */
    15	class HybridRnBottomSheet: HybridRnBottomSheetSpec {
    16	
    17	    // =========================================================================
    18	    // MARK: - UIView (required by HybridViewSpec)
    19	    // =========================================================================
    20	
file update:
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning line spacing adjustments**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && nl -ba ios/RnBottomSheet.swift | sed -n '260,460p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
   260	                    case "large":
   261	                        result.append(.large())
   262	                    default:
   263	                        break
   264	                    }
   265	                }
   266	            case "fraction":
   267	                if let value = config["value"] as? Double {
   268	                    if #available(iOS 16.0, *) {
   269	                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
   270	                        result.append(.custom(identifier: identifier) { _ in
   271	                            return UIScreen.main.bounds.height * CGFloat(value)
   272	                        })
   273	                    }
   274	                }
   275	            case "points":
   276	                if let value = config["value"] as? Double {
   277	                    if #available(iOS 16.0, *) {
   278	                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
   279	                        result.append(.custom(identifier: identifier) { _ in
file update:
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Designing unified detent parsing and caching**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -196,4 +196,4 @@
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
@@ -202,3 +202,3 @@
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
@@ -221,10 +221,12 @@
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
@@ -248,48 +250,43 @@
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
+    }
 
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
-
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
@@ -307,6 +304,6 @@
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
apply_patch(auto_approved=true) exited 0 in 57ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..9659ab80c914ce0579c572e6677ea1a4bc1878cc
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
+    }
 
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
-
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..9659ab80c914ce0579c572e6677ea1a4bc1878cc
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
+    }
 
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
-
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Adding helper methods and struct definitions**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -416,4 +416,4 @@
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
apply_patch(auto_approved=true) exited 0 in 64ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..74be1eeb402a04483744c9660f9012dd2fbe1e0b
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -417,8 +414,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..74be1eeb402a04483744c9660f9012dd2fbe1e0b
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -417,8 +414,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning helper insertion**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -386,2 +386,157 @@
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
apply_patch(auto_approved=true) exited 0 in 71ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..445c3ad21cd3419e283dfe576d020fbb04c8b31c
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..445c3ad21cd3419e283dfe576d020fbb04c8b31c
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Adding supporting struct**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
@@ -600,2 +600,16 @@
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
apply_patch(auto_approved=true) exited 0 in 69ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/ios/RnBottomSheet.swift
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning comprehensive detent tests**
file update
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet.detents.test.ts
import type { BottomSheetDetent } from '../types/bottom-sheet';
import {
  detentToNativeIdentifier,
  detentsToNativeConfig,
  getDetentIdentifier,
  normalizeDetents,
  validateDetent,
  validateDetents,
} from '../utils/detents';

describe('detent utilities', () => {
  it('accepts semantic fit detent', () => {
    expect(validateDetent('fit')).toBeNull();
  });

  it('rejects invalid fraction values', () => {
    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
      'between 0 and 1'
    );
  });

  it('rejects non-positive points values', () => {
    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
  });

  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
    const detents: BottomSheetDetent[] = [
      'large',
      { type: 'points', value: 200, id: 'content' },
      'medium',
      'fit',
      { type: 'fraction', value: 0.8 },
      { type: 'points', value: 200, id: 'duplicate-id' },
      'medium',
    ];

    expect(normalizeDetents(detents)).toEqual([
      { type: 'points', value: 200, id: 'content' },
      'fit',
      'medium',
      { type: 'fraction', value: 0.8 },
      'large',
    ]);
  });

  it('returns deterministic identifier values', () => {
    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
    expect(
      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
    ).toBe('fraction:hero');
    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
      'points:320'
    );
  });

  it('validates unique custom detent ids', () => {
    const result = validateDetents([
      { type: 'fraction', value: 0.4, id: 'dup' },
      { type: 'points', value: 360, id: 'dup' },
    ]);

    expect(result.valid).toBe(false);
    expect(result.error).toContain("Duplicate detent id 'dup'");
  });

  it('returns normalized detents when validation succeeds', () => {
    const result = validateDetents(['large', 'fit', { type: 'fraction', value: 0.6 }]);

    expect(result.valid).toBe(true);
    expect(result.normalizedDetents).toEqual([
      'fit',
      { type: 'fraction', value: 0.6 },
      'large',
    ]);
  });

  it('maps detents to native config with deterministic identifiers', () => {
    const config = detentsToNativeConfig([
      { type: 'fraction', value: 0.6, id: 'hero detent' },
      'fit',
    ]);

    expect(config).toEqual([
      {
        type: 'semantic',
        value: 'fit',
        identifier: 'fit',
        detent: 'fit',
      },
      {
        type: 'fraction',
        value: 0.6,
        identifier: 'hero_detent',
        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
      },
    ]);
  });

  it('falls back to generated identifier when custom id is not provided', () => {
    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
      'points_300_2'
    );
  });
});
apply_patch(auto_approved=true) exited 0 in 72ms:
Success. Updated the following files:
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet.detents.test.ts
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544eaf79302203b6e40015d9830e2f03e742752
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,104 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents(['large', 'fit', { type: 'fraction', value: 0.6 }]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544eaf79302203b6e40015d9830e2f03e742752
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,104 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents(['large', 'fit', { type: 'fraction', value: 0.6 }]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning code quality checks**
codex
Core detent changes are in place across TypeScript and Swift plus a dedicated detent test suite. I’m running lint/typecheck/tests now to validate behavior and catch any integration issues before I update plan/status files.

thinking
**Combining lint, typecheck, test commands**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && yarn lint && yarn typecheck && yarn test' in /Users/tolu/Desktop/dev/rn-bottom-sheet exited 1 in 1.93s:

/Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet.detents.test.ts
  67:37  error  Replace `'large',·'fit',·{·type:·'fraction',·value:·0.6·}` with `⏎······'large',⏎······'fit',⏎······{·type:·'fraction',·value:·0.6·},⏎····`  prettier/prettier

/Users/tolu/Desktop/dev/rn-bottom-sheet/src/utils/detents.ts
   95:75  error  Replace `detent.value` with `⏎········detent.value⏎······`                                        prettier/prettier
  105:73  error  Replace `detent.value` with `⏎········detent.value⏎······`                                        prettier/prettier
  116:28  error  Replace `detent:·FractionDetent·|·PointsDetent` with `⏎··detent:·FractionDetent·|·PointsDetent⏎`  prettier/prettier
  283:39  error  Replace `⏎··detents:·BottomSheetDetent[]⏎` with `detents:·BottomSheetDetent[]`                    prettier/prettier

✖ 5 problems (5 errors, 0 warnings)
  5 errors and 0 warnings potentially fixable with the `--fix` option.

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544eaf79302203b6e40015d9830e2f03e742752
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,104 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents(['large', 'fit', { type: 'fraction', value: 0.6 }]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning manual formatting fix**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && nl -ba src/utils/detents.ts | sed -n '80,140p' && nl -ba src/utils/detents.ts | sed -n '260,320p' && nl -ba src/__tests__/bottom-sheet.detents.test.ts | sed -n '56,90p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
    80	    return 'Detent id must not be empty';
    81	  }
    82	  return null;
    83	}
    84	
    85	/**
    86	 * Validate a single detent value.
    87	 */
    88	export function validateDetent(detent: BottomSheetDetent): string | null {
    89	  if (isSemanticDetent(detent)) {
    90	    return null;
    91	  }
    92	
    93	  if (isFractionDetent(detent)) {
    94	    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
    95	      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
    96	    }
    97	    if (detent.value < 0 || detent.value > 1) {
    98	      return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
    99	    }
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544eaf79302203b6e40015d9830e2f03e742752
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,104 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents(['large', 'fit', { type: 'fraction', value: 0.6 }]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..c3e45e492f31e10f00d178a9925167a6ffaa17a0
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,54 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(detent.value)}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(detent: FractionDetent | PointsDetent): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +137,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +148,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
+
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
   }
-
-  const normalized = normalizeDetents(detents);
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +174,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +186,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +209,112 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
+    return detent;
   }
 
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
-  }
-
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
 export function detentsToNativeConfig(
   detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Applying ESLint auto-fixes**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && yarn eslint src/utils/detents.ts src/__tests__/bottom-sheet.detents.test.ts --fix' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.35s:

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && yarn lint && yarn typecheck && yarn test' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 3.36s:
PASS src/__tests__/bottom-sheet.detents.test.ts
PASS src/__tests__/bottom-sheet.contract.test.ts
PASS src/__tests__/index.test.tsx

Test Suites: 3 passed, 3 total
Tests:       19 todo, 9 passed, 28 total
Snapshots:   0 total
Time:        0.36 s, estimated 1 s
Ran all test suites.
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Planning task and todo updates**
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && sed -n '1,340p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
# Implementation Todo

## Phase 0: Project Memory Bootstrap

- [x] Create `docs/` knowledge base structure
- [x] Add decision-complete implementation plan
- [x] Add reference summaries and source index
- [x] Add ADRs for primary architecture decisions
- [x] Add sync/check scripts for docs integrity

## Phase 1: API and Nitro Contract

- [x] Finalize public TypeScript API and Nitro view contract
- [x] Regenerate Nitrogen artifacts
- [x] Validate typings and exports

## Phase 2: iOS Sheet Engine

- [ ] Implement presenter/controller architecture
- [ ] Map detent model and lifecycle events
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..cacc81561d9e5c44bd52fe09b0f7f87cae9be91e
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -74,3 +74,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [ ] Add/extend unit tests for normalization + validation edge cases
+- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Adding review entry and checkmarks**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
@@ -64,6 +64,10 @@
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
@@ -79,7 +83,7 @@
 
-- [ ] Confirm highest-priority incomplete item and verify current code does not already satisfy it
-- [ ] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
-- [ ] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
-- [ ] Add/extend unit tests for normalization + validation edge cases
-- [ ] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
-- [ ] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section
apply_patch(auto_approved=true) exited 0 in 72ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && nl -ba IMPLEMENTATION_PLAN.md | sed -n '14,36p' && nl -ba IMPLEMENTATION_PLAN.md | sed -n '56,66p'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
    14	- [x] [HIGH] Regenerate Nitrogen artifacts after contract changes - from tasks/todo.md Phase 1
    15	- [x] [HIGH] Validate typings compile and exports work correctly - from tasks/todo.md Phase 1
    16	- [x] [HIGH] Update src/index.tsx to export all public types - from IMPLEMENTATION_PLAN API Design
    17	
    18	### Phase 2: iOS Sheet Engine
    19	
    20	- [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
    21	- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
    22	- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
    23	- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
    24	- [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
    25	- [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
    26	- [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
    27	- [ ] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
    28	- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
    29	- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
    30	- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
    31	- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
    32	- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
    33	- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
file update:
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Confirming bidirectional detent mapping**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/IMPLEMENTATION_PLAN.md
@@ -20,5 +20,5 @@
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
@@ -58,3 +58,3 @@
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
apply_patch(auto_approved=true) exited 0 in 77ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/IMPLEMENTATION_PLAN.md
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Clarifying commit scope amid unrelated changes**
codex
Implementation and verification are complete for the selected high-priority detent work item, and I’ve updated both `tasks/todo.md` and `IMPLEMENTATION_PLAN.md` progress. I’ll do a final diff review, then commit and push only the relevant files for this iteration to avoid bundling unrelated pre-existing workspace changes.
exec
/bin/zsh -lc "cd /Users/tolu/Desktop/dev/rn-bottom-sheet && git status --short && printf '\\n## changed files diff summary\\n' && git diff --stat" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 53ms:
 M IMPLEMENTATION_PLAN.md
 M ios/RnBottomSheet.swift
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
 M src/RnBottomSheet.nitro.ts
 M src/types/bottom-sheet.ts
 M src/utils/detents.ts
 M tasks/todo.md
?? logs/
?? src/__tests__/bottom-sheet.detents.test.ts
?? yarn.lock

## changed files diff summary
 IMPLEMENTATION_PLAN.md      |   8 +-
 ios/RnBottomSheet.swift     | 704 ++++++++++++++++++++++++++++++++++++++++++--
 scripts/ralph-loop-codex.sh |   6 +-
 scripts/ralph-loop.sh       |   6 +-
 src/RnBottomSheet.nitro.ts  |   2 +-
 src/types/bottom-sheet.ts   |   5 +-
 src/utils/detents.ts        | 168 ++++++++---
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Preparing selective commit despite large iOS diff**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && git add IMPLEMENTATION_PLAN.md ios/RnBottomSheet.swift src/RnBottomSheet.nitro.ts src/types/bottom-sheet.ts src/utils/detents.ts src/__tests__/bottom-sheet.detents.test.ts tasks/todo.md && git status --short' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
M  IMPLEMENTATION_PLAN.md
M  ios/RnBottomSheet.swift
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
M  src/RnBottomSheet.nitro.ts
A  src/__tests__/bottom-sheet.detents.test.ts
M  src/types/bottom-sheet.ts
M  src/utils/detents.ts
M  tasks/todo.md
?? logs/
?? yarn.lock
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Committing staged changes**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && git commit -m "feat: normalize and validate detents across JS and iOS"' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.51s:
┃  types ❯ 

[1G[0K⠙[1G[0K[1G[0K⠙[1G[0K
┃  lint ❯ 

[1G[0K⠙[1G[0K[1G[0K⠙[1G[0K
                                      
  ────────────────────────────────────
summary: (done in 1.17 seconds)       
✔️ types (0.91 seconds)
✔️ lint (1.16 seconds)
╭──────────────────────────────────────╮
│ 🥊 lefthook v2.1.1  hook: commit-msg │
╰──────────────────────────────────────╯
┃  commitlint ❯ 

[1G[0K[1G[0K⠙[1G[0K
                                      
  ────────────────────────────────────
summary: (done in 0.33 seconds)       
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Verifying staged changes**
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && git status --short' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
?? logs/
?? yarn.lock
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Pushing committed changes**
codex
I committed the detent normalization/validation work and left unrelated pre-existing script/log/lockfile changes unstaged. I’m pushing this commit to `main` now and then I’ll return the completion signal if everything required is satisfied.
exec
/bin/zsh -lc 'cd /Users/tolu/Desktop/dev/rn-bottom-sheet && git push' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 749ms:
To https://github.com/tolulawson/rn-bottom-sheet.git
   7dc3513..ff0e744  main -> main
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section


thinking
**Confirming all checks passed**
codex
<promise>DONE</promise>
file update:
diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index d7ff5a166bf882f9608429c32102acc65017a3cc..a9ed3efb86c077ee22daa127917986644306088f
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -18,9 +18,9 @@
 ### Phase 2: iOS Sheet Engine
 
 - [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
-- [ ] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
-- [ ] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
+- [x] [HIGH] Implement detent normalization (fit/medium/large/fraction/points to native identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Implement detent validation (order low-to-high, unique identifiers) - from ios-sheet-apis.md
+- [x] [HIGH] Map selectedDetentIdentifier bidirectionally - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
 - [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
@@ -56,7 +56,7 @@
 
 ### Phase 5: Verification and Release Readiness
 
-- [ ] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
+- [x] [HIGH] Add unit tests for detent normalization logic - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add unit tests for API prop validation - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for presenter lifecycle - from IMPLEMENTATION_PLAN Verification
 - [ ] [HIGH] Add iOS integration tests for detent behavior - from IMPLEMENTATION_PLAN Verification
diff --git a/ios/RnBottomSheet.swift b/ios/RnBottomSheet.swift
index 9220bb354c75a68fa6aedaf3246d36054262635b..d3f8fd38ac5f659060b10f85e6f90191d68aa011
--- a/ios/RnBottomSheet.swift
+++ b/ios/RnBottomSheet.swift
@@ -194,13 +194,13 @@
             return
         }
 
-        let nativeDetents = buildNativeDetents()
-        guard index >= 0 && index < nativeDetents.count else {
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+        guard index >= 0 && index < detentIdentifiers.count else {
             print("[RnBottomSheet] Invalid detent index: \(index)")
             return
         }
 
-        let targetIdentifier = nativeDetents[index].identifier
+        let targetIdentifier = detentIdentifiers[index]
 
         if animated {
             sheet.animateChanges {
@@ -219,14 +219,16 @@
     // =========================================================================
 
     private func configureSheetController(_ sheet: UISheetPresentationController) {
+        let nativeDetents = buildNativeDetents()
+        let detentIdentifiers = buildNativeDetentIdentifiers()
+
         // Set detents
-        sheet.detents = buildNativeDetents()
+        sheet.detents = nativeDetents
 
         // Set initial selection
-        let nativeDetents = buildNativeDetents()
         let initialIndex = Int(initialDetentIndex)
-        if initialIndex >= 0 && initialIndex < nativeDetents.count {
-            sheet.selectedDetentIdentifier = nativeDetents[initialIndex].identifier
+        if initialIndex >= 0 && initialIndex < detentIdentifiers.count {
+            sheet.selectedDetentIdentifier = detentIdentifiers[initialIndex]
         }
 
         // Configure appearance
@@ -246,52 +248,47 @@
     }
 
     private func buildNativeDetents() -> [UISheetPresentationController.Detent] {
-        var result: [UISheetPresentationController.Detent] = []
-
-        for config in detents {
-            guard let type = config["type"] as? String else { continue }
-
-            switch type {
-            case "semantic":
-                if let value = config["value"] as? String {
-                    switch value {
-                    case "medium":
-                        result.append(.medium())
-                    case "large":
-                        result.append(.large())
-                    default:
-                        break
+        let definitions = buildValidatedDetentDefinitions()
+        return definitions.map { definition in
+            switch definition.kind {
+            case .semanticFit:
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { [weak self] context in
+                        guard let self else {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        let fittedHeight = self.view.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
+                        if fittedHeight <= 0 {
+                            return max(120, context.maximumDetentValue * 0.25)
+                        }
+                        return min(max(120, fittedHeight), context.maximumDetentValue)
                     }
                 }
-            case "fraction":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "fraction_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return UIScreen.main.bounds.height * CGFloat(value)
-                        })
+                return .medium()
+            case .semanticMedium:
+                return .medium()
+            case .semanticLarge:
+                return .large()
+            case .fraction(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(context.maximumDetentValue, context.maximumDetentValue * CGFloat(value))
                     }
                 }
-            case "points":
-                if let value = config["value"] as? Double {
-                    if #available(iOS 16.0, *) {
-                        let identifier = UISheetPresentationController.Detent.Identifier(config["identifier"] as? String ?? "points_\(value)")
-                        result.append(.custom(identifier: identifier) { _ in
-                            return CGFloat(value)
-                        })
+                return .medium()
+            case .points(let value):
+                if #available(iOS 16.0, *) {
+                    return .custom(identifier: definition.identifier) { context in
+                        return min(CGFloat(value), context.maximumDetentValue)
                     }
                 }
-            default:
-                break
+                return .medium()
             }
         }
-
-        // Default to medium and large if no valid detents
-        if result.isEmpty {
-            result = [.medium(), .large()]
-        }
+    }
 
-        return result
+    private func buildNativeDetentIdentifiers() -> [UISheetPresentationController.Detent.Identifier] {
+        return buildValidatedDetentDefinitions().map(\.identifier)
     }
 
     private func applyBackgroundInteraction(to sheet: UISheetPresentationController) {
@@ -305,10 +302,10 @@
                 break
             }
         } else if let index = backgroundInteraction as? Double {
-            let nativeDetents = buildNativeDetents()
+            let nativeDetents = buildNativeDetentIdentifiers()
             let idx = Int(index)
             if idx >= 0 && idx < nativeDetents.count {
-                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx].identifier
+                sheet.largestUndimmedDetentIdentifier = nativeDetents[idx]
             }
         }
     }
@@ -387,6 +384,161 @@
     }
 
     // =========================================================================
+    // MARK: - Detent Parsing and Validation
+    // =========================================================================
+
+    private func buildValidatedDetentDefinitions() -> [ValidatedNativeDetent] {
+        var definitions: [ValidatedNativeDetent] = []
+        var seenResolvedValues = Set<String>()
+        var seenIdentifiers = Set<String>()
+
+        for (index, config) in detents.enumerated() {
+            guard let type = config["type"] as? String else {
+                print("[RnBottomSheet] Invalid detent at index \(index): missing 'type'")
+                continue
+            }
+
+            let providedIdentifier = (config["identifier"] as? String)?
+                .trimmingCharacters(in: .whitespacesAndNewlines)
+
+            switch type {
+            case "semantic":
+                guard let value = config["value"] as? String else {
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): missing string value")
+                    continue
+                }
+
+                let kind: ValidatedNativeDetent.Kind
+                let sortValue: Double
+                switch value {
+                case "fit":
+                    kind = .semanticFit
+                    sortValue = 0.25
+                case "medium":
+                    kind = .semanticMedium
+                    sortValue = 0.5
+                case "large":
+                    kind = .semanticLarge
+                    sortValue = 1.0
+                default:
+                    print("[RnBottomSheet] Invalid semantic detent at index \(index): '\(value)'")
+                    continue
+                }
+
+                let resolvedKey = "semantic:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : value)
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: sortValue,
+                        kind: kind
+                    )
+                )
+
+            case "fraction":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value >= 0, value <= 1 else {
+                    print("[RnBottomSheet] Invalid fraction detent at index \(index): value must be between 0 and 1")
+                    continue
+                }
+
+                let resolvedKey = "fraction:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "fraction_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value,
+                        kind: .fraction(value)
+                    )
+                )
+
+            case "points":
+                guard let value = numericValue(from: config["value"]) else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be numeric")
+                    continue
+                }
+                guard value > 0 else {
+                    print("[RnBottomSheet] Invalid points detent at index \(index): value must be greater than 0")
+                    continue
+                }
+
+                let resolvedKey = "points:\(value)"
+                if seenResolvedValues.contains(resolvedKey) {
+                    continue
+                }
+                seenResolvedValues.insert(resolvedKey)
+
+                let identifierString = (providedIdentifier?.isEmpty == false ? providedIdentifier! : "points_\(value)")
+                if seenIdentifiers.contains(identifierString) {
+                    print("[RnBottomSheet] Duplicate detent identifier '\(identifierString)'")
+                    continue
+                }
+                seenIdentifiers.insert(identifierString)
+
+                definitions.append(
+                    ValidatedNativeDetent(
+                        identifier: .init(identifierString),
+                        sortValue: value / 1000,
+                        kind: .points(value)
+                    )
+                )
+
+            default:
+                print("[RnBottomSheet] Invalid detent at index \(index): unsupported type '\(type)'")
+            }
+        }
+
+        if definitions.isEmpty {
+            return [
+                ValidatedNativeDetent(identifier: .medium, sortValue: 0.5, kind: .semanticMedium),
+                ValidatedNativeDetent(identifier: .large, sortValue: 1.0, kind: .semanticLarge),
+            ]
+        }
+
+        return definitions.sorted {
+            if $0.sortValue == $1.sortValue {
+                return $0.identifier.rawValue < $1.identifier.rawValue
+            }
+            return $0.sortValue < $1.sortValue
+        }
+    }
+
+    private func numericValue(from raw: Any?) -> Double? {
+        if let value = raw as? Double {
+            return value
+        }
+        if let value = raw as? NSNumber {
+            return value.doubleValue
+        }
+        return nil
+    }
+
+    // =========================================================================
     // MARK: - Helpers
     // =========================================================================
 
@@ -417,8 +569,8 @@
         // Find the index of the new detent
         guard let identifier = sheetPresentationController.selectedDetentIdentifier else { return }
 
-        let nativeDetents = buildNativeDetents()
-        if let index = nativeDetents.firstIndex(where: { $0.identifier == identifier }) {
+        let nativeDetents = buildNativeDetentIdentifiers()
+        if let index = nativeDetents.firstIndex(where: { $0 == identifier }) {
             currentDetentIndex = index
             onDetentChange?(Double(index), "swipe")
         }
@@ -446,6 +598,20 @@
 // MARK: - Supporting Types
 // =============================================================================
 
+private struct ValidatedNativeDetent {
+    enum Kind {
+        case semanticFit
+        case semanticMedium
+        case semanticLarge
+        case fraction(Double)
+        case points(Double)
+    }
+
+    let identifier: UISheetPresentationController.Detent.Identifier
+    let sortValue: Double
+    let kind: Kind
+}
+
 /// Protocol for sheet presenter delegate
 protocol SheetPresenterDelegate: AnyObject {
     func sheetWillDismiss(reason: String)
diff --git a/src/RnBottomSheet.nitro.ts b/src/RnBottomSheet.nitro.ts
index 027a69700a21b7bda461bbc457ab3928f7f1ffcc..407d7507d90391a6c2a1a0cd63e478ea9c1ba848
--- a/src/RnBottomSheet.nitro.ts
+++ b/src/RnBottomSheet.nitro.ts
@@ -26,7 +26,7 @@
 export interface NativeDetentConfig {
   /** Detent type: 'semantic', 'fraction', or 'points' */
   type: NativeDetentType;
-  /** For semantic: 'medium' or 'large'. For fraction/points: numeric value */
+  /** For semantic: 'fit', 'medium', or 'large'. For fraction/points: numeric value */
   value: string | number;
   /** Unique identifier for this detent */
   identifier: string;
diff --git a/src/__tests__/bottom-sheet.detents.test.ts b/src/__tests__/bottom-sheet.detents.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7e2ab8f3f28c095cef249ae6c3c2ca59d81ab85
--- /dev/null
+++ b/src/__tests__/bottom-sheet.detents.test.ts
@@ -0,0 +1,108 @@
+import type { BottomSheetDetent } from '../types/bottom-sheet';
+import {
+  detentToNativeIdentifier,
+  detentsToNativeConfig,
+  getDetentIdentifier,
+  normalizeDetents,
+  validateDetent,
+  validateDetents,
+} from '../utils/detents';
+
+describe('detent utilities', () => {
+  it('accepts semantic fit detent', () => {
+    expect(validateDetent('fit')).toBeNull();
+  });
+
+  it('rejects invalid fraction values', () => {
+    expect(validateDetent({ type: 'fraction', value: 1.2 })).toContain(
+      'between 0 and 1'
+    );
+  });
+
+  it('rejects non-positive points values', () => {
+    expect(validateDetent({ type: 'points', value: 0 })).toContain('positive');
+  });
+
+  it('normalizes detents to low-to-high order and deduplicates by resolved value', () => {
+    const detents: BottomSheetDetent[] = [
+      'large',
+      { type: 'points', value: 200, id: 'content' },
+      'medium',
+      'fit',
+      { type: 'fraction', value: 0.8 },
+      { type: 'points', value: 200, id: 'duplicate-id' },
+      'medium',
+    ];
+
+    expect(normalizeDetents(detents)).toEqual([
+      { type: 'points', value: 200, id: 'content' },
+      'fit',
+      'medium',
+      { type: 'fraction', value: 0.8 },
+      'large',
+    ]);
+  });
+
+  it('returns deterministic identifier values', () => {
+    expect(getDetentIdentifier('fit')).toBe('semantic:fit');
+    expect(
+      getDetentIdentifier({ type: 'fraction', value: 0.6, id: 'hero' })
+    ).toBe('fraction:hero');
+    expect(getDetentIdentifier({ type: 'points', value: 320 })).toBe(
+      'points:320'
+    );
+  });
+
+  it('validates unique custom detent ids', () => {
+    const result = validateDetents([
+      { type: 'fraction', value: 0.4, id: 'dup' },
+      { type: 'points', value: 360, id: 'dup' },
+    ]);
+
+    expect(result.valid).toBe(false);
+    expect(result.error).toContain("Duplicate detent id 'dup'");
+  });
+
+  it('returns normalized detents when validation succeeds', () => {
+    const result = validateDetents([
+      'large',
+      'fit',
+      { type: 'fraction', value: 0.6 },
+    ]);
+
+    expect(result.valid).toBe(true);
+    expect(result.normalizedDetents).toEqual([
+      'fit',
+      { type: 'fraction', value: 0.6 },
+      'large',
+    ]);
+  });
+
+  it('maps detents to native config with deterministic identifiers', () => {
+    const config = detentsToNativeConfig([
+      { type: 'fraction', value: 0.6, id: 'hero detent' },
+      'fit',
+    ]);
+
+    expect(config).toEqual([
+      {
+        type: 'semantic',
+        value: 'fit',
+        identifier: 'fit',
+        detent: 'fit',
+      },
+      {
+        type: 'fraction',
+        value: 0.6,
+        identifier: 'hero_detent',
+        detent: { type: 'fraction', value: 0.6, id: 'hero detent' },
+      },
+    ]);
+  });
+
+  it('falls back to generated identifier when custom id is not provided', () => {
+    expect(detentToNativeIdentifier({ type: 'points', value: 300 }, 2)).toBe(
+      'points_300_2'
+    );
+  });
+});
diff --git a/src/types/bottom-sheet.ts b/src/types/bottom-sheet.ts
index 3b6d3ff99c89f188fce4b2b2813ecf1fc988cc4e..49d2a7cb502658c557658f324440f80647f2c9a9
--- a/src/types/bottom-sheet.ts
+++ b/src/types/bottom-sheet.ts
@@ -12,7 +12,7 @@
 /**
  * Semantic detent identifiers that map to iOS system detents.
  */
-export type SemanticDetent = 'medium' | 'large';
+export type SemanticDetent = 'fit' | 'medium' | 'large';
 
 /**
  * Fraction-based detent (0..1 range representing percentage of screen height).
@@ -21,6 +21,7 @@
 export interface FractionDetent {
   type: 'fraction';
   value: number; // 0..1
+  id?: string;
 }
 
 /**
@@ -30,10 +31,12 @@
 export interface PointsDetent {
   type: 'points';
   value: number; // > 0
+  id?: string;
 }
 
 /**
  * All supported detent types.
+ * - 'fit': Content-fitting custom detent
  * - 'medium': ~50% of screen height (iOS system detent)
  * - 'large': Full available height (iOS system detent)
  * - FractionDetent: Custom fraction of container height
diff --git a/src/utils/detents.ts b/src/utils/detents.ts
index 9ed7c9544eea7c03185fd7ab442d3883b6ec63a4..7cdb955431e80fdbaea82aa1297befed402e01c8
--- a/src/utils/detents.ts
+++ b/src/utils/detents.ts
@@ -17,17 +17,19 @@
 // Constants
 // =============================================================================
 
-const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['medium', 'large'];
+const SEMANTIC_DETENTS: readonly SemanticDetent[] = ['fit', 'medium', 'large'];
 
 /**
- * Approximate height values for semantic detents (used for sorting).
- * These are relative values, not actual pixel values.
+ * Approximate relative height values for semantic detents (used for sorting).
  */
 const SEMANTIC_HEIGHT_VALUES: Record<SemanticDetent, number> = {
+  fit: 0.25,
   medium: 0.5,
   large: 1.0,
 };
 
+const POINTS_REFERENCE_HEIGHT = 1000;
+
 // =============================================================================
 // Type Guards
 // =============================================================================
@@ -67,37 +69,60 @@
 // Validation
 // =============================================================================
 
+function validateCustomId(id: unknown): string | null {
+  if (id === undefined) {
+    return null;
+  }
+  if (typeof id !== 'string') {
+    return `Detent id must be a string when provided, got ${typeof id}`;
+  }
+  if (id.trim().length === 0) {
+    return 'Detent id must not be empty';
+  }
+  return null;
+}
+
 /**
  * Validate a single detent value.
  */
 export function validateDetent(detent: BottomSheetDetent): string | null {
   if (isSemanticDetent(detent)) {
-    return null; // Valid
+    return null;
   }
 
   if (isFractionDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Fraction detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Fraction detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value < 0 || detent.value > 1) {
       return `Fraction detent value must be between 0 and 1, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   if (isPointsDetent(detent)) {
-    if (typeof detent.value !== 'number') {
-      return `Points detent value must be a number, got ${typeof detent.value}`;
+    if (typeof detent.value !== 'number' || !Number.isFinite(detent.value)) {
+      return `Points detent value must be a finite number, got ${String(
+        detent.value
+      )}`;
     }
     if (detent.value <= 0) {
       return `Points detent value must be positive, got ${detent.value}`;
     }
-    return null;
+    return validateCustomId(detent.id);
   }
 
   return `Invalid detent type: ${JSON.stringify(detent)}`;
 }
 
+function getCustomDetentId(
+  detent: FractionDetent | PointsDetent
+): string | null {
+  return typeof detent.id === 'string' && detent.id.trim() ? detent.id : null;
+}
+
 /**
  * Validate an array of detents.
  */
@@ -118,6 +143,8 @@
     };
   }
 
+  const customIds = new Set<string>();
+
   for (let i = 0; i < detents.length; i++) {
     const detent = detents[i]!;
     const error = validateDetent(detent);
@@ -127,13 +154,24 @@
         error: `Invalid detent at index ${i}: ${error}`,
       };
     }
-  }
 
-  const normalized = normalizeDetents(detents);
+    if (isFractionDetent(detent) || isPointsDetent(detent)) {
+      const customId = getCustomDetentId(detent);
+      if (customId) {
+        if (customIds.has(customId)) {
+          return {
+            valid: false,
+            error: `Duplicate detent id '${customId}' is not allowed`,
+          };
+        }
+        customIds.add(customId);
+      }
+    }
+  }
 
   return {
     valid: true,
-    normalizedDetents: normalized,
+    normalizedDetents: normalizeDetents(detents),
   };
 }
 
@@ -142,9 +180,7 @@
 // =============================================================================
 
 /**
- * Get a comparable height value for a detent (used for sorting).
- * For semantic and fraction detents, returns a 0..1 value.
- * For points detents, returns a large value to sort them based on points.
+ * Get a comparable height value for a detent (used for low-to-high sorting).
  */
 export function getDetentSortValue(detent: BottomSheetDetent): number {
   if (isSemanticDetent(detent)) {
@@ -156,18 +192,13 @@
   }
 
   if (isPointsDetent(detent)) {
-    // For points, we assume a reference height of 1000 for sorting purposes
-    // This allows points to be compared relatively with fractions
-    return detent.value / 1000;
+    return detent.value / POINTS_REFERENCE_HEIGHT;
   }
 
   return 0;
 }
 
-/**
- * Generate a unique identifier for a detent (used for deduplication).
- */
-export function getDetentIdentifier(detent: BottomSheetDetent): string {
+function getResolvedDetentKey(detent: BottomSheetDetent): string {
   if (isSemanticDetent(detent)) {
     return `semantic:${detent}`;
   }
@@ -184,65 +215,110 @@
 }
 
 /**
- * Normalize detents: sort low-to-high and deduplicate.
+ * Generate a deterministic identifier for a detent.
+ */
+export function getDetentIdentifier(detent: BottomSheetDetent): string {
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return `${detent.type}:${customId}`;
+    }
+  }
+  return getResolvedDetentKey(detent);
+}
+
+/**
+ * Normalize detents by deduplicating resolved values and sorting low-to-high.
  */
 export function normalizeDetents(
   detents: BottomSheetDetent[]
 ): BottomSheetDetent[] {
-  // Deduplicate by identifier
   const seen = new Set<string>();
   const unique: BottomSheetDetent[] = [];
 
   for (const detent of detents) {
-    const id = getDetentIdentifier(detent);
-    if (!seen.has(id)) {
-      seen.add(id);
+    const key = getResolvedDetentKey(detent);
+    if (!seen.has(key)) {
+      seen.add(key);
       unique.push(detent);
     }
   }
 
-  // Sort by height value (low to high)
-  return unique.sort((a, b) => getDetentSortValue(a) - getDetentSortValue(b));
+  return unique.sort((a, b) => {
+    const valueDiff = getDetentSortValue(a) - getDetentSortValue(b);
+    if (valueDiff !== 0) {
+      return valueDiff;
+    }
+    return getDetentIdentifier(a).localeCompare(getDetentIdentifier(b));
+  });
 }
 
 // =============================================================================
 // Native Identifier Mapping
 // =============================================================================
 
+function sanitizeIdentifier(value: string): string {
+  return value.replace(/[^a-zA-Z0-9_-]/g, '_');
+}
+
 /**
  * Convert a detent to its native iOS identifier.
- * Used for bridging to UISheetPresentationController.
  */
 export function detentToNativeIdentifier(
   detent: BottomSheetDetent,
   index: number
 ): string {
   if (isSemanticDetent(detent)) {
-    return detent; // 'medium' or 'large' map directly
-  }
-
-  if (isFractionDetent(detent)) {
-    return `fraction_${detent.value}_${index}`;
+    return detent;
   }
 
-  if (isPointsDetent(detent)) {
-    return `points_${detent.value}_${index}`;
+  if (isFractionDetent(detent) || isPointsDetent(detent)) {
+    const customId = getCustomDetentId(detent);
+    if (customId) {
+      return sanitizeIdentifier(customId);
+    }
+    return `${detent.type}_${detent.value}_${index}`;
   }
 
   return `custom_${index}`;
 }
 
 /**
- * Convert an array of detents to native identifier mapping.
+ * Convert detents to native bridge config objects.
  */
-export function detentsToNativeConfig(
-  detents: BottomSheetDetent[]
-): Array<{ identifier: string; detent: BottomSheetDetent }> {
+export function detentsToNativeConfig(detents: BottomSheetDetent[]): Array<{
+  type: 'semantic' | 'fraction' | 'points';
+  value: string | number;
+  identifier: string;
+  detent: BottomSheetDetent;
+}> {
   const normalized = normalizeDetents(detents);
-  return normalized.map((detent, index) => ({
-    identifier: detentToNativeIdentifier(detent, index),
-    detent,
-  }));
+  return normalized.map((detent, index) => {
+    if (isSemanticDetent(detent)) {
+      return {
+        type: 'semantic',
+        value: detent,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    if (isFractionDetent(detent)) {
+      return {
+        type: 'fraction',
+        value: detent.value,
+        identifier: detentToNativeIdentifier(detent, index),
+        detent,
+      };
+    }
+
+    return {
+      type: 'points',
+      value: detent.value,
+      identifier: detentToNativeIdentifier(detent, index),
+      detent,
+    };
+  });
 }
 
 // =============================================================================
diff --git a/tasks/todo.md b/tasks/todo.md
index 2abde6417c16d7437589facdbd45a867ed3f79e5..ebf956b3928354f946d8e0f6aa39da573133f884
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -62,10 +62,14 @@
   - `yarn nitrogen` initially failed due Nitro parser limitations in `src/RnBottomSheet.nitro.ts` (inline union type and mixed string-literal/number union). Resolved by extracting `NativeDetentType` and widening `NativeBackgroundInteraction` bridge type to `string | number`.
   - `yarn typecheck` initially failed in `example/src/App.tsx` because Nitro view callbacks were passed as plain functions. Resolved by wrapping callback props with `callback(...)` from `react-native-nitro-modules`.
   - `yarn lint`, `yarn typecheck`, and `yarn test` now pass.
+  - Added `fit` detent support to public type model and deterministic JS/native detent normalization rules (sorted low-to-high, deduped resolved values, unique custom ids).
+  - Added detent validation coverage and native mapping tests in `src/__tests__/bottom-sheet.detents.test.ts`.
 - Residual Risks:
   - `NativeBackgroundInteraction` bridge typing is wider (`string | number`) than intended semantic domain and depends on JS-side validation/documentation for stricter correctness.
+  - Swift detent validation currently logs invalid configuration and falls back/defaults instead of surfacing explicit JS exceptions through the bridge.
 - Follow-ups:
   - Add explicit JS-level validation around `backgroundInteraction` before sending values to native layer.
+  - Add JS wrapper-level API validation so invalid detent config fails before reaching native.
 
 ## Ralph Iteration 2026-02-12 (Phase 1 Verification Blocker)
 
@@ -74,3 +78,12 @@
 - [x] Fix callback wiring/type mismatches in `example/src/App.tsx` so `yarn typecheck` passes
 - [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Record verification outcomes in Review section and update completed checkboxes
+
+## Ralph Iteration 2026-02-12 (Phase 2 High-Priority Detent Gap)
+
+- [x] Confirm highest-priority incomplete item and verify current code does not already satisfy it
+- [x] Implement complete detent normalization coverage (`fit`, `medium`, `large`, `fraction`, `points`) in JS/native bridge types and helpers
+- [x] Implement strict detent validation rules (ordering, uniqueness, range) and deterministic error messages
+- [x] Add/extend unit tests for normalization + validation edge cases
+- [x] Run and pass: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Update `IMPLEMENTATION_PLAN.md` progress and capture results in Review section

tokens used
99,665
<promise>DONE</promise>
