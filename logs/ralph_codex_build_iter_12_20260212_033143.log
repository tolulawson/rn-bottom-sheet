OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/tolu/Desktop/dev/rn-bottom-sheet
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c519f-09f5-7b70-ae32-9718bea7a985
--------
user
# Ralph Build Mode

Based on Geoffrey Huntley's Ralph Wiggum methodology.

---

## Phase 0: Orient

Read `.specify/memory/constitution.md` to understand project principles and constraints.

---

## Phase 1: Discover Work Items

Search for incomplete work from these sources (in order):

1. **specs/ folder** — Look for `.md` files NOT marked `## Status: COMPLETE`
2. **IMPLEMENTATION_PLAN.md** — If exists, find unchecked `- [ ]` tasks
3. **GitHub Issues** — Check for open issues (if this is a GitHub repo)
4. **Any task tracker** — Jira, Linear, etc. if configured

Pick the **HIGHEST PRIORITY** incomplete item:
- Lower numbers = higher priority (001 before 010)
- `[HIGH]` before `[MEDIUM]` before `[LOW]`
- Bugs/blockers before features

Before implementing, search the codebase to verify it's not already done.

---

## Phase 1b: Re-Verification Mode (No Incomplete Work Found)

**If ALL specs appear complete**, don't just exit — do a quality check:

1. **Randomly pick** one completed spec from `specs/`
2. **Strictly re-verify** ALL its acceptance criteria:
   - Run the actual tests mentioned in the spec
   - Manually verify each criterion is truly met
   - Check edge cases
   - Look for regressions
3. **If any criterion fails**: Unmark the spec as complete and fix it
4. **If all pass**: Output `<promise>DONE</promise>` to confirm quality

This ensures the codebase stays healthy even when "nothing to do."

---

## Phase 2: Implement

Implement the selected spec/task completely:
- Follow the spec's requirements exactly
- Write clean, maintainable code
- Add tests as needed

---

## Phase 3: Validate

Run the project's test suite and verify:
- All tests pass
- No lint errors
- The spec's acceptance criteria are 100% met

---

## Phase 3b: Conditional Maestro MCP E2E Gate (Example App)

Identify the active feature spec and check its E2E gate marker:
- Look for `E2E Gate State: deferred|required` in `specs/<feature>/spec.md`.
- Default to `deferred` if the marker is missing.

Gate behavior:
- If `deferred`: do NOT block this loop iteration. Log that Maestro MCP was skipped and why.
- If `required`: Maestro MCP is a hard gate for completion.

When `required`, run Maestro MCP against the example app and verify at least:
- sheet opens from example UI
- sheet dismisses cleanly
- detent interaction works
- primary in-sheet navigation flow works

If any required Maestro MCP flow fails, do NOT output `<promise>DONE</promise>`.

---

## Phase 4: Commit & Update

1. Mark the spec/task as complete (add `## Status: COMPLETE` to spec file)
2. `git add -A`
3. `git commit` with a descriptive message
4. `git push`

---

## Completion Signal

**CRITICAL:** Only output the magic phrase when the work is 100% complete.

Check:
- [ ] Implementation matches all requirements
- [ ] All tests pass
- [ ] All acceptance criteria verified
- [ ] Maestro MCP gate satisfied (or explicitly deferred in the active spec)
- [ ] Changes committed and pushed
- [ ] Spec marked as complete

**If ALL checks pass, output:** `<promise>DONE</promise>`

**If ANY check fails:** Fix the issue and try again. Do NOT output the magic phrase.

mcp: codex_apps starting
mcp: maestro starting
mcp: context7 starting
mcp: codex_apps ready
mcp: maestro ready
mcp: context7 ready
mcp startup: ready: codex_apps, maestro, context7

thinking
**Starting initial repository exploration**
codex
I’m starting the Ralph build loop now: first I’ll read the project constitution, then scan specs and planning files to pick the highest-priority incomplete item, verify it isn’t already implemented, and execute the full implement/validate/commit flow.

thinking
**Listing repository files**
exec
/bin/zsh -lc 'pwd; ls -la' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
/Users/tolu/desktop/dev/rn-bottom-sheet
total 1184
drwxr-xr-x   46 tolu  staff    1472 Feb 12 02:30 .
drwxr-xr-x@ 108 tolu  staff    3456 Feb 12 02:05 ..
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .claude
drwxr-xr-x    3 tolu  staff      96 Feb 12 02:11 .codex
drwxr-xr-x@   3 tolu  staff      96 Feb 12 01:44 .cursor
-rw-r--r--@   1 tolu  staff     283 Feb 12 00:45 .editorconfig
drwxr-xr-x@  14 tolu  staff     448 Feb 12 03:31 .git
-rw-r--r--@   1 tolu  staff      72 Feb 12 00:45 .gitattributes
drwxr-xr-x@   5 tolu  staff     160 Feb 12 00:45 .github
-rw-r--r--@   1 tolu  staff     866 Feb 12 01:45 .gitignore
-rw-r--r--@   1 tolu  staff       9 Feb 12 00:45 .nvmrc
drwxr-xr-x@   5 tolu  staff     160 Feb 12 02:02 .specify
-rw-r--r--@   1 tolu  staff       2 Feb 12 00:45 .watchmanconfig
drwxr-xr-x@   4 tolu  staff     128 Feb 12 02:26 .yarn
-rw-r--r--@   1 tolu  staff      96 Feb 12 00:45 .yarnrc.yml
-rw-------@   1 tolu  staff     756 Feb 12 02:13 AGENTS.md
-rw-r--r--@   1 tolu  staff     119 Feb 12 01:44 CLAUDE.md
-rw-r--r--@   1 tolu  staff    5489 Feb 12 00:45 CODE_OF_CONDUCT.md

thinking
**Planning detailed task breakdown**
codex
I’ve confirmed repo structure and will now gather the required context: constitution, spec statuses, unchecked implementation-plan items, and tracker state so we can select the single highest-priority unfinished item.

thinking
**Planning parallel file reads**
exec
/bin/zsh -lc "sed -n '1,220p' .specify/memory/constitution.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'rg --files specs | sort' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'rg -n "''^## Status:|''^- '"\\[ \\]\" specs IMPLEMENTATION_PLAN.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
<!--
Sync Impact Report
Version change: 1.0.0 -> 1.1.0
Modified principles:
- Native Fidelity First -> I. Native Fidelity First
- Verification Before Completion -> II. Verification Before Completion
- Simplicity -> III. Minimal, Intentional Scope
Added principles:
- IV. Living Knowledge Base
- V. Deterministic Integration Contracts
Added sections:
- Operational Constraints
- Workflow & Quality Gates
Removed sections:
- Ralph-specific loop mechanics as governing principle source
Templates/runtime sync status:
- ✅ .specify/templates/plan-template.md (Constitution Check gates aligned)
- ✅ .specify/templates/spec-template.md (reviewed, no change required)
- ✅ .specify/templates/tasks-template.md (reviewed, no change required)
- ✅ AGENTS.md (already points to constitution)
 succeeded in 52ms:
specs/001-native-ios-sheet-bindings/checklists/native-sheet.md
specs/001-native-ios-sheet-bindings/checklists/requirements.md
specs/001-native-ios-sheet-bindings/contracts/bottom-sheet-api.yaml
specs/001-native-ios-sheet-bindings/data-model.md
specs/001-native-ios-sheet-bindings/plan.md
specs/001-native-ios-sheet-bindings/quickstart.md
specs/001-native-ios-sheet-bindings/research.md
specs/001-native-ios-sheet-bindings/spec.md
specs/001-native-ios-sheet-bindings/tasks.md
 succeeded in 52ms:
IMPLEMENTATION_PLAN.md:20:- [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
IMPLEMENTATION_PLAN.md:24:- [ ] [HIGH] Implement present() flow with completion callback - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:25:- [ ] [HIGH] Implement dismiss() flow with reason mapping - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:26:- [ ] [HIGH] Implement lifecycle event bridge (onWillPresent, onDidPresent, onWillDismiss, onDidDismiss) - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:27:- [ ] [HIGH] Implement dismissal reason detection (swipe, backdrop, programmatic, system) - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:28:- [ ] [MEDIUM] Implement grabberVisible prop mapping to prefersGrabberVisible - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:29:- [ ] [MEDIUM] Implement allowSwipeToDismiss behavior - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:30:- [ ] [MEDIUM] Implement expandsWhenScrolledToEdge mapping - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:31:- [ ] [MEDIUM] Implement cornerRadius mapping - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:32:- [ ] [MEDIUM] Implement largestUndimmedDetent mapping - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:33:- [ ] [MEDIUM] Implement backgroundInteraction behavior - from IMPLEMENTATION_PLAN API Design
IMPLEMENTATION_PLAN.md:34:- [ ] [MEDIUM] Implement snapToDetent() with animateChanges batching - from ios-sheet-apis.md
IMPLEMENTATION_PLAN.md:35:- [ ] [LOW] Implement single active sheet enforcement (manager-level ownership) - from IMPLEMENTATION_PLAN Architecture
IMPLEMENTATION_PLAN.md:39:- [ ] [HIGH] Create native container view for RN children inside sheet - from ADR-0002
IMPLEMENTATION_PLAN.md:40:- [ ] [HIGH] Implement RN children mounting into native-hosted container - from ADR-0002
IMPLEMENTATION_PLAN.md:41:- [ ] [HIGH] Implement attach lifecycle handling - from nitro-view-components.md
IMPLEMENTATION_PLAN.md:42:- [ ] [HIGH] Implement detach lifecycle handling - from nitro-view-components.md
IMPLEMENTATION_PLAN.md:43:- [ ] [HIGH] Implement prepareForRecycle() for recycled view cleanup - from nitro-view-components.md
IMPLEMENTATION_PLAN.md:44:- [ ] [MEDIUM] Handle thread-safety for props arriving from different threads - from nitro-view-components.md
IMPLEMENTATION_PLAN.md:45:- [ ] [MEDIUM] Implement beforeUpdate()/afterUpdate() for batched prop application - from nitro-view-components.md

thinking
**Assessing incomplete tasks and specs**
codex
I found many unchecked items in both `specs/.../tasks.md` and `IMPLEMENTATION_PLAN.md`; next I’m identifying the true highest-priority item per your ordering rules and checking whether it’s already implemented before touching code.

thinking
**Examining task specifications and plans**
exec
/bin/zsh -lc "sed -n '1,260p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' specs/001-native-ios-sheet-bindings/spec.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' specs/001-native-ios-sheet-bindings/tasks.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 53ms:
# Implementation Todo

## Phase 0: Project Memory Bootstrap

- [x] Create `docs/` knowledge base structure
- [x] Add decision-complete implementation plan
- [x] Add reference summaries and source index
- [x] Add ADRs for primary architecture decisions
- [x] Add sync/check scripts for docs integrity

## Phase 1: API and Nitro Contract

- [x] Finalize public TypeScript API and Nitro view contract
- [x] Regenerate Nitrogen artifacts
- [x] Validate typings and exports

## Phase 2: iOS Sheet Engine

- [ ] Implement presenter/controller architecture
- [ ] Map detent model and lifecycle events
 succeeded in 53ms:
# Tasks: Native iOS Sheet Bindings

**Input**: Design documents from `/Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/`  
**Prerequisites**: plan.md (required), spec.md (required), research.md, data-model.md, contracts/, quickstart.md

**Tests**: Include tests because the specification requires automated verification coverage for API and integration behavior.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (`[US1]`, `[US2]`, `[US3]`)
- Include exact file paths in descriptions

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Prepare feature scaffolding, generated bindings workflow, and test harness entry points.

- [x] T001 Create feature README entry and scope note in docs/changelog-notes/README.md
 succeeded in 53ms:
# Feature Specification: Native iOS Sheet Bindings

**Feature Branch**: `001-native-ios-sheet-bindings`  
**Created**: 2026-02-12  
**Status**: Draft  
**Input**: User description: "Build a React Native library that provides native iOS sheet bindings using Nitro Views with React Native children, dynamic detents, React Navigation integration, in-sheet navigation, and Reanimated-compatible APIs."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Present Native Sheet Content (Priority: P1)

As a React Native developer, I can present and dismiss a native-feeling iOS sheet that renders arbitrary React Native child content so that product experiences match Apple sheet behavior.

**Why this priority**: This is the core product value and the minimum viable capability for the package.

**Independent Test**: In an example app, the developer can open/close a sheet and see custom React Native children rendered correctly without writing custom native code.

**Acceptance Scenarios**:

1. **Given** a screen using the library, **When** the developer triggers open state, **Then** a native iOS sheet appears and displays provided child content.

thinking
**Determining highest-priority incomplete task**
codex
I’ve confirmed `specs/001.../tasks.md` has the next unfinished story tasks (`T027+`), and I’m now checking GitHub/other tracker signals plus current code so we can verify the top item isn’t already done before implementing.

thinking
**Checking existing implementation**
exec
/bin/zsh -lc 'git remote -v' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'ls -la src/navigation 2>/dev/null || true; rg -n "bottom-sheet-adapter|useBottomSheetNavigation|navigation adapter" src example docs' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
origin	https://github.com/tolulawson/rn-bottom-sheet.git (fetch)
origin	https://github.com/tolulawson/rn-bottom-sheet.git (push)
 exited 1 in 51ms:

exec
/bin/zsh -lc 'gh issue list --state open --limit 50' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 426ms:


thinking
**Planning focused T027 implementation**
exec
/bin/zsh -lc "sed -n '1,260p' src/index.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,320p' src/components/BottomSheet.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,280p' src/__tests__/bottom-sheet.navigation.test.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg -n \"navigation|adapter|useBottomSheetNavigation\" specs/001-native-ios-sheet-bindings/*.md docs -g '*.md'" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 53ms:
import React, { createRef } from 'react';
import TestRenderer from 'react-test-renderer';
import { BottomSheet } from '../components/BottomSheet';
import type { RnBottomSheetProps } from '../RnBottomSheet.nitro';
import type { BottomSheetMethods } from '../types/bottom-sheet';

type MockRnBottomSheetViewProps = RnBottomSheetProps & {
  hybridRef?: (instance: unknown) => void;
};

const mockNativeMethods = {
  present: jest.fn(),
  dismiss: jest.fn(),
  snapToDetent: jest.fn(),
  getCurrentDetentIndex: jest.fn(),
};

let mockLatestProps: MockRnBottomSheetViewProps | null = null;

jest.mock('react-native-nitro-modules', () => ({
 succeeded in 53ms:
/**
 * rn-bottom-sheet
 *
 * Native iOS sheet bindings for React Native using Nitro Views.
 */

import { BottomSheet } from './components/BottomSheet';
import { RnBottomSheetView } from './native/RnBottomSheetView';

// =============================================================================
// Public Components
// =============================================================================

/**
 * Public BottomSheet wrapper component.
 */
export { BottomSheet };

/**
 * Internal native view component export for advanced use-cases.
 succeeded in 53ms:
import { callback, type HybridRef } from 'react-native-nitro-modules';
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from 'react';
import { View } from 'react-native';
import type {
  NativeChangeReason,
  RnBottomSheetMethods,
  RnBottomSheetProps,
} from '../RnBottomSheet.nitro';
import { RnBottomSheetView } from '../native/RnBottomSheetView';
import {
  isNativeSheetSupported,
  warnUnsupportedPlatform,
 succeeded in 52ms:
specs/001-native-ios-sheet-bindings/data-model.md:49:- Purpose: Optional mapping between sheet lifecycle and navigation/animation layers.
specs/001-native-ios-sheet-bindings/data-model.md:51:  - `navigationSyncEnabled` (boolean)
specs/001-native-ios-sheet-bindings/plan.md:8:Deliver an iOS-first React Native bottom sheet library built on Nitro Views that presents native iOS sheets, renders arbitrary React Native child content, supports deterministic detent and lifecycle control, and provides optional navigation/animation integration with explicit contract boundaries.
specs/001-native-ios-sheet-bindings/plan.md:13:**Primary Dependencies**: react-native 0.81.5, react-native-nitro-modules 0.33.x, nitrogen, optional react-navigation and react-native-reanimated adapters  
specs/001-native-ios-sheet-bindings/quickstart.md:23:1. Wire optional navigation adapter helper.
specs/001-native-ios-sheet-bindings/spec.md:6:**Input**: User description: "Build a React Native library that provides native iOS sheet bindings using Nitro Views with React Native children, dynamic detents, React Navigation integration, in-sheet navigation, and Reanimated-compatible APIs."
specs/001-native-ios-sheet-bindings/spec.md:48:**Independent Test**: In a sample flow, a nested navigation journey inside the sheet works, and supported animation wrappers run without breaking sheet state.
specs/001-native-ios-sheet-bindings/spec.md:52:1. **Given** an app route triggers a sheet flow, **When** route state changes, **Then** sheet open/close state can be synchronized with navigation behavior.
specs/001-native-ios-sheet-bindings/spec.md:53:2. **Given** nested navigation content inside the sheet, **When** the user navigates between internal screens, **Then** the sheet remains stable and navigation actions resolve predictably.
specs/001-native-ios-sheet-bindings/spec.md:81:- **FR-011**: System MUST allow navigation content within the sheet without forcing a custom navigation stack API.
specs/001-native-ios-sheet-bindings/spec.md:84:- **FR-014**: System MUST include an example app demonstrating core usage, detent configuration, navigation integration, and animation interoperability.
specs/001-native-ios-sheet-bindings/spec.md:93:- **Integration Binding**: Represents optional synchronization mapping between navigation state, sheet state, and callbacks.
specs/001-native-ios-sheet-bindings/spec.md:112:- **SC-003**: In example app test runs, primary user flows (open, dismiss, detent change, in-sheet navigation) complete successfully in at least 95% of runs without manual recovery.
specs/001-native-ios-sheet-bindings/spec.md:115:- **SC-006**: When `E2E Gate State` is `required`, Maestro MCP flows for the example app pass for open, dismiss, detent interaction, and in-sheet navigation in 100% of release-gate runs.
specs/001-native-ios-sheet-bindings/spec.md:121:- Integration with navigation and animation is scoped to documented supported pathways rather than unlimited interoperability guarantees.
specs/001-native-ios-sheet-bindings/tasks.md:94:**Independent Test**: Example app can drive a sheet from navigation state and run supported animated wrapper flow without state breakage.
specs/001-native-ios-sheet-bindings/tasks.md:98:- [x] T025 [P] [US3] Add navigation-sync behavior tests in src/__tests__/bottom-sheet.navigation.test.ts
specs/001-native-ios-sheet-bindings/tasks.md:103:- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
specs/001-native-ios-sheet-bindings/tasks.md:104:- [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
specs/001-native-ios-sheet-bindings/tasks.md:107:- [ ] T031 [US3] Add example navigation + animation scenarios in example/src/App.tsx

thinking
**Reviewing navigation adapter design docs**
exec
/bin/zsh -lc "sed -n '1,220p' specs/001-native-ios-sheet-bindings/quickstart.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' docs/adr/ADR-0003-navigation-adapter-boundary.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,260p' docs/references/react-navigation-form-sheet.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,220p' specs/001-native-ios-sheet-bindings/contracts/bottom-sheet-api.yaml" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# ADR-0003: Keep React Navigation Support as Optional Adapter

- Status: Accepted
- Date: 2026-02-12

## Context

Consumers need React Navigation compatibility, but hard-coupling the core package increases dependency and upgrade risk.

## Decision

Keep core sheet package navigation-agnostic; publish optional adapter utilities under a separate subpath/package boundary.

## Consequences

1. Lower coupling and cleaner core API.
2. Easier support for non-React-Navigation consumers.
3. Adapter package carries specific integration complexity.
 succeeded in 52ms:
# Quickstart: Native iOS Sheet Bindings

## 1. Install and Prepare

1. Install dependencies and run codegen.
2. Ensure New Architecture/Fabric is enabled.
3. Build and run the example app on iOS.

## 2. Minimal Usage Flow

1. Render sheet component with simple child content.
2. Toggle open state.
3. Observe present/dismiss callbacks.

## 3. Detent Configuration Flow

1. Provide a detent list with initial detent.
2. Trigger user drag/programmatic snap.
3. Validate detent change callback and current detent state.

 succeeded in 52ms:
# React Navigation Form Sheet Notes

## Why It Matters

Consumers need navigation interoperability with native sheet presentation.

## Key Observations (Native Stack)

1. `presentation: 'formSheet'` exists in native stack docs and exposes sheet-related options.
2. Options include `sheetAllowedDetents`, `sheetGrabberVisible`, and related behavior controls.
3. Docs call out known platform integration limitations for some `flex: 1` and nested scenarios.

## Nesting Behavior

1. Navigation actions are handled by the current navigator first, then bubble to parents.
2. In nested sheet flows, `goBack()` behavior must be coordinated to avoid unexpected dismiss/pop ordering.

## Implications for rn-bottom-sheet

1. Keep core package navigation-agnostic.
 succeeded in 52ms:
contract: bottom-sheet-component
version: 1

component:
  name: BottomSheet
  props:
    isOpen:
      type: boolean
      required: false
    defaultOpen:
      type: boolean
      required: false
    detents:
      type: array
      items: detent
      required: false
    initialDetent:
      type: integer_or_last
      required: false
    selectedDetent:

thinking
**Inspecting plan documentation**
exec
/bin/zsh -lc "sed -n '1,320p' specs/001-native-ios-sheet-bindings/plan.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,280p' specs/001-native-ios-sheet-bindings/data-model.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'ls -la src; find src -maxdepth 2 -type f | sort' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 50ms:
# Implementation Plan: Native iOS Sheet Bindings

**Branch**: `001-native-ios-sheet-bindings` | **Date**: 2026-02-12 | **Spec**: `/Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/spec.md`
**Input**: Feature specification from `/Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/spec.md`

## Summary

Deliver an iOS-first React Native bottom sheet library built on Nitro Views that presents native iOS sheets, renders arbitrary React Native child content, supports deterministic detent and lifecycle control, and provides optional navigation/animation integration with explicit contract boundaries.

## Technical Context

**Language/Version**: TypeScript 5.9 (public API), Swift 5 (iOS native layer), Kotlin (existing Android fallback path)  
**Primary Dependencies**: react-native 0.81.5, react-native-nitro-modules 0.33.x, nitrogen, optional react-navigation and react-native-reanimated adapters  
**Storage**: N/A (runtime UI behavior only)  
**Testing**: Jest for JS contract tests, iOS integration checks in example app target, Maestro for end-to-end flows  
**Target Platform**: iOS 16+ (primary), non-iOS deterministic fallback behavior  
**Project Type**: Mobile React Native library with example app  
**Performance Goals**: Native sheet interactions maintain smooth 60fps feel in example scenarios; open/dismiss transitions perceived as immediate for standard content  
**Constraints**: New Architecture/Fabric required; single active sheet session in v1; non-iOS parity explicitly out of scope; no crash on unsupported platforms  
**Scale/Scope**: One publishable library package, one example app, and one complete feature spec/plan/tasks artifact set
 succeeded in 52ms:
# Data Model: Native iOS Sheet Bindings

## Entity: BottomSheetConfiguration

- Purpose: Declares runtime behavior and interaction settings for one sheet instance.
- Fields:
  - `isOpen` (boolean, optional, controlled state)
  - `defaultOpen` (boolean, optional, uncontrolled initial state)
  - `detents` (list of `DetentDefinition`)
  - `initialDetent` (index or `last`)
  - `selectedDetent` (index, optional controlled detent)
  - `grabberVisible` (boolean)
  - `allowSwipeToDismiss` (boolean)
  - `backgroundInteractionMode` (`modal` or threshold mode)
- Validation Rules:
  - Detent list must be non-empty when provided.
  - Detent values must be valid and sortable.
  - Detent indexes must resolve to an existing detent.

## Entity: DetentDefinition
 succeeded in 53ms:
total 24
drwxr-xr-x@ 10 tolu  staff   320 Feb 12 02:47 .
drwxr-xr-x  46 tolu  staff  1472 Feb 12 02:30 ..
-rw-r--r--@  1 tolu  staff  4823 Feb 12 02:38 RnBottomSheet.nitro.ts
drwxr-xr-x@ 10 tolu  staff   320 Feb 12 03:29 __tests__
drwxr-xr-x@  4 tolu  staff   128 Feb 12 02:48 components
-rw-r--r--@  1 tolu  staff  2354 Feb 12 02:48 index.tsx
drwxr-xr-x@  3 tolu  staff    96 Feb 12 02:47 native
drwxr-xr-x@  3 tolu  staff    96 Feb 12 02:24 platform
drwxr-xr-x@  3 tolu  staff    96 Feb 12 02:23 types
drwxr-xr-x@  3 tolu  staff    96 Feb 12 02:38 utils
src/RnBottomSheet.nitro.ts
src/__tests__/bottom-sheet.contract.test.ts
src/__tests__/bottom-sheet.detents.test.ts
src/__tests__/bottom-sheet.lifecycle.test.ts
src/__tests__/bottom-sheet.methods.test.ts
src/__tests__/bottom-sheet.navigation.test.ts
src/__tests__/bottom-sheet.reanimated.test.ts
src/__tests__/bottom-sheet.wrapper.test.ts
src/__tests__/index.test.tsx

thinking
**Preparing plan update commentary**
codex
I’ve selected `T027` as the highest-priority unfinished item from the spec task list (`US3`, first unchecked task), and confirmed there is no existing `src/navigation/bottom-sheet-adapter.ts` implementation.  
Next I’ll execute this plan and track it in `tasks/todo.md` before coding:

1. Add a new Ralph iteration checklist in `tasks/todo.md` for `T027`.
2. Design and implement a minimal optional navigation adapter helper API in `src/navigation/bottom-sheet-adapter.ts` aligned with existing `BottomSheet` props/callback semantics.
3. Add focused unit tests for the adapter behavior (sync callbacks, loop prevention guardrails, deterministic route-state mapping).
4. Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
5. Run `yarn lint`, `yarn typecheck`, `yarn test`.
6. Record verification outcomes in `tasks/todo.md` review log, then commit and push.

I’m starting with step 1 now.

thinking
**Planning update steps**
Plan update
  → Write T027 iteration checklist to tasks/todo.md
  • Implement optional navigation adapter helper in src/navigation/bottom-sheet-adapter.ts
  • Add adapter unit tests
  • Mark task completion and run validation commands
  • Document results, commit, and push

thinking
**Planning to append unchecked items section**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
@@ -191 +191,10 @@
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning update tool implementation**
codex
The execution checklist for `T027` is now written in `tasks/todo.md`. I’m moving into implementation next: defining the adapter API and wiring tests before running full validation.
Plan update
  ✓ Write T027 iteration checklist to tasks/todo.md
  → Implement optional navigation adapter helper in src/navigation/bottom-sheet-adapter.ts
  • Add adapter unit tests
  • Mark task completion and run validation commands
  • Document results, commit, and push
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Inspecting types and callbacks**
exec
/bin/zsh -lc "sed -n '1,360p' src/types/bottom-sheet.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
/**
 * Bottom Sheet Type Definitions
 *
 * Core type definitions for the bottom sheet API.
 * These types are used across the JS and native layers.
 */

// =============================================================================
// Detent Types
// =============================================================================

/**
 * Semantic detent identifiers that map to iOS system detents.
 */
export type SemanticDetent = 'fit' | 'medium' | 'large';

/**
 * Fraction-based detent (0..1 range representing percentage of screen height).
 * Maps to UISheetPresentationController.Detent.custom(identifier:resolver:)
 */
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning Jest and ts-jest review**
exec
/bin/zsh -lc 'cat jest.config.js' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'cat package.json' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '1,220p' src/__tests__/index.test.tsx" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 51ms:
{
  "name": "rn-bottom-sheet",
  "version": "0.1.0",
  "description": "Native bindings to SwiftUI sheet",
  "main": "./lib/module/index.js",
  "types": "./lib/typescript/src/index.d.ts",
  "exports": {
    ".": {
      "source": "./src/index.tsx",
      "types": "./lib/typescript/src/index.d.ts",
      "default": "./lib/module/index.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "lib",
    "android",
    "ios",
    "cpp",
 exited 1 in 51ms:
cat: jest.config.js: No such file or directory
 succeeded in 52ms:
it.todo('write a test');
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning helper functions placement**
exec
/bin/zsh -lc "sed -n '1,260p' IMPLEMENTATION_PLAN.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
# Implementation Plan

> Auto-generated breakdown of specs into tasks.
> Delete this file to return to working directly from specs.

## Priority Tasks

### Phase 1: API and Nitro Contract

- [x] [HIGH] Define complete TypeScript type model (BottomSheetDetent, BottomSheetChangeReason) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with full public props interface - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Update RnBottomSheet.nitro.ts with public methods (present, dismiss, snapToDetent, getCurrentDetentIndex) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Define callback prop types (onOpenChange, onDetentChange, lifecycle callbacks) - from IMPLEMENTATION_PLAN API Design
- [x] [HIGH] Regenerate Nitrogen artifacts after contract changes - from tasks/todo.md Phase 1
- [x] [HIGH] Validate typings compile and exports work correctly - from tasks/todo.md Phase 1
- [x] [HIGH] Update src/index.tsx to export all public types - from IMPLEMENTATION_PLAN API Design

### Phase 2: iOS Sheet Engine

- [ ] [HIGH] Create SheetPresenterViewController using UISheetPresentationController - from ADR-0001
file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Assessing navigation adapter scope**
exec
/bin/zsh -lc "sed -n '1,260p' src/platform/fallback.ts" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
/**
 * Non-iOS Fallback Utilities
 *
 * Provides deterministic fallback behavior for non-iOS platforms.
 * Per constitution: Non-iOS platforms get explicit fallback (no crash).
 */

import { Platform } from 'react-native';

// =============================================================================
// Platform Detection
// =============================================================================

/**
 * Check if native sheet is supported on current platform.
 */
export function isNativeSheetSupported(): boolean {
  return Platform.OS === 'ios';
}

file update:
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Designing optional navigation adapter helper**
codex
I’m now editing code for `T027`: creating `src/navigation/bottom-sheet-adapter.ts` with a navigation-sync helper API that maps route state to controlled `BottomSheet` props and guards against open/close feedback loops, then I’ll add dedicated unit tests for that behavior.

thinking
**Implementing adapter and hook with tests**
file update
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/navigation/bottom-sheet-adapter.ts
import { useMemo, useRef } from 'react';
import type {
  BottomSheetChangeReason,
  OnOpenChangeCallback,
} from '../types/bottom-sheet';

/**
 * Configuration for mapping route state to controlled BottomSheet props.
 */
export interface BottomSheetNavigationAdapterOptions {
  /**
   * Whether the navigation state expects the sheet to be open.
   */
  routeIsOpen: boolean;
  /**
   * Called when the sheet requests an open transition.
   */
  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
  /**
   * Called when the sheet requests a close transition.
   */
  onRouteClose?: (reason: BottomSheetChangeReason) => void;
  /**
   * Optional side-effect callback for observing open changes.
   */
  onOpenChange?: OnOpenChangeCallback;
}

/**
 * Controlled BottomSheet props derived from navigation state.
 */
export interface BottomSheetNavigationAdapter {
  isOpen: boolean;
  onOpenChange: OnOpenChangeCallback;
}

function handleRouteSync(
  nextOpen: boolean,
  reason: BottomSheetChangeReason,
  routeIsOpen: boolean,
  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
  onRouteClose?: (reason: BottomSheetChangeReason) => void
): void {
  if (nextOpen === routeIsOpen) {
    return;
  }

  if (nextOpen) {
    onRouteOpen?.(reason);
    return;
  }

  onRouteClose?.(reason);
}

/**
 * Build controlled BottomSheet props from route state.
 * Re-create this adapter when route state changes.
 */
export function createBottomSheetNavigationAdapter(
  options: BottomSheetNavigationAdapterOptions
): BottomSheetNavigationAdapter {
  return {
    isOpen: options.routeIsOpen,
    onOpenChange(nextOpen, reason) {
      options.onOpenChange?.(nextOpen, reason);
      handleRouteSync(
        nextOpen,
        reason,
        options.routeIsOpen,
        options.onRouteOpen,
        options.onRouteClose
      );
    },
  };
}

/**
 * Hook variant that keeps callback behavior aligned with the latest route state.
 */
export function useBottomSheetNavigation(
  options: BottomSheetNavigationAdapterOptions
): BottomSheetNavigationAdapter {
  const routeIsOpenRef = useRef(options.routeIsOpen);
  routeIsOpenRef.current = options.routeIsOpen;

  return useMemo(
    () => ({
      isOpen: options.routeIsOpen,
      onOpenChange(nextOpen, reason) {
        options.onOpenChange?.(nextOpen, reason);
        handleRouteSync(
          nextOpen,
          reason,
          routeIsOpenRef.current,
          options.onRouteOpen,
          options.onRouteClose
        );
      },
    }),
    [
      options.onOpenChange,
      options.onRouteClose,
      options.onRouteOpen,
      options.routeIsOpen,
    ]
  );
}
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/navigation/bottom-sheet-adapter.ts
file update:
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Adding React Native Jest tests**
file update
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet-adapter.test.ts
import React, { useEffect } from 'react';
import TestRenderer from 'react-test-renderer';
import {
  createBottomSheetNavigationAdapter,
  useBottomSheetNavigation,
  type BottomSheetNavigationAdapter,
} from '../navigation/bottom-sheet-adapter';

describe('createBottomSheetNavigationAdapter', () => {
  it('maps route state to controlled isOpen', () => {
    const adapter = createBottomSheetNavigationAdapter({
      routeIsOpen: true,
    });

    expect(adapter.isOpen).toBe(true);
  });

  it('requests route close when native sheet closes while route is open', () => {
    const onOpenChange = jest.fn();
    const onRouteClose = jest.fn();
    const onRouteOpen = jest.fn();
    const adapter = createBottomSheetNavigationAdapter({
      routeIsOpen: true,
      onOpenChange,
      onRouteClose,
      onRouteOpen,
    });

    adapter.onOpenChange(false, 'swipe');

    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
    expect(onRouteClose).toHaveBeenCalledWith('swipe');
    expect(onRouteOpen).not.toHaveBeenCalled();
  });

  it('does not request route state changes when sheet state already matches', () => {
    const onRouteClose = jest.fn();
    const onRouteOpen = jest.fn();
    const adapter = createBottomSheetNavigationAdapter({
      routeIsOpen: false,
      onRouteClose,
      onRouteOpen,
    });

    adapter.onOpenChange(false, 'programmatic');

    expect(onRouteClose).not.toHaveBeenCalled();
    expect(onRouteOpen).not.toHaveBeenCalled();
  });
});

interface HookHarnessProps {
  routeIsOpen: boolean;
  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
  onRouteOpen?: (reason: 'programmatic' | 'swipe' | 'backdrop' | 'system') => void;
  onRouteClose?: (
    reason: 'programmatic' | 'swipe' | 'backdrop' | 'system'
  ) => void;
}

function HookHarness({
  routeIsOpen,
  onAdapter,
  onRouteOpen,
  onRouteClose,
}: HookHarnessProps) {
  const adapter = useBottomSheetNavigation({
    routeIsOpen,
    onRouteOpen,
    onRouteClose,
  });

  useEffect(() => {
    onAdapter(adapter);
  }, [adapter, onAdapter]);

  return null;
}

describe('useBottomSheetNavigation', () => {
  it('uses latest route state when handling open changes', () => {
    const onRouteOpen = jest.fn();
    const onRouteClose = jest.fn();
    let latestAdapter: BottomSheetNavigationAdapter | null = null;
    let renderer: TestRenderer.ReactTestRenderer;

    TestRenderer.act(() => {
      renderer = TestRenderer.create(
        <HookHarness
          routeIsOpen={false}
          onRouteOpen={onRouteOpen}
          onRouteClose={onRouteClose}
          onAdapter={(adapter) => {
            latestAdapter = adapter;
          }}
        />
      );
    });

    TestRenderer.act(() => {
      latestAdapter?.onOpenChange(true, 'programmatic');
    });
    expect(onRouteOpen).toHaveBeenCalledTimes(1);

    TestRenderer.act(() => {
      renderer!.update(
        <HookHarness
          routeIsOpen={true}
          onRouteOpen={onRouteOpen}
          onRouteClose={onRouteClose}
          onAdapter={(adapter) => {
            latestAdapter = adapter;
          }}
        />
      );
    });

    TestRenderer.act(() => {
      latestAdapter?.onOpenChange(true, 'programmatic');
      latestAdapter?.onOpenChange(false, 'swipe');
    });

    expect(onRouteOpen).toHaveBeenCalledTimes(1);
    expect(onRouteClose).toHaveBeenCalledWith('swipe');
  });
});
apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
A /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet-adapter.test.ts
file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5f8d1fd0cae06c4278e6d087808ac96f3ac9bd4e
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,126 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: 'programmatic' | 'swipe' | 'backdrop' | 'system') => void;
+  onRouteClose?: (
+    reason: 'programmatic' | 'swipe' | 'backdrop' | 'system'
+  ) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        <HookHarness
+          routeIsOpen={false}
+          onRouteOpen={onRouteOpen}
+          onRouteClose={onRouteClose}
+          onAdapter={(adapter) => {
+            latestAdapter = adapter;
+          }}
+        />
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        <HookHarness
+          routeIsOpen={true}
+          onRouteOpen={onRouteOpen}
+          onRouteClose={onRouteClose}
+          onAdapter={(adapter) => {
+            latestAdapter = adapter;
+          }}
+        />
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5f8d1fd0cae06c4278e6d087808ac96f3ac9bd4e
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,126 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: 'programmatic' | 'swipe' | 'backdrop' | 'system') => void;
+  onRouteClose?: (
+    reason: 'programmatic' | 'swipe' | 'backdrop' | 'system'
+  ) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        <HookHarness
+          routeIsOpen={false}
+          onRouteOpen={onRouteOpen}
+          onRouteClose={onRouteClose}
+          onAdapter={(adapter) => {
+            latestAdapter = adapter;
+          }}
+        />
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        <HookHarness
+          routeIsOpen={true}
+          onRouteOpen={onRouteOpen}
+          onRouteClose={onRouteClose}
+          onAdapter={(adapter) => {
+            latestAdapter = adapter;
+          }}
+        />
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Refactoring test to avoid JSX and improve typing**
codex
I’ve added the adapter implementation and a new test file; I’m making a quick cleanup pass now to ensure TypeScript/Jest compatibility before running lint/typecheck/tests.

thinking
**Removing unused JSX and union types import**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet-adapter.test.ts
@@ -7,2 +7,3 @@
 } from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
 
@@ -54,6 +55,4 @@
   onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
-  onRouteOpen?: (reason: 'programmatic' | 'swipe' | 'backdrop' | 'system') => void;
-  onRouteClose?: (
-    reason: 'programmatic' | 'swipe' | 'backdrop' | 'system'
-  ) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
 }
@@ -88,10 +87,10 @@
       renderer = TestRenderer.create(
-        <HookHarness
-          routeIsOpen={false}
-          onRouteOpen={onRouteOpen}
-          onRouteClose={onRouteClose}
-          onAdapter={(adapter) => {
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
             latestAdapter = adapter;
-          }}
-        />
+          },
+        })
       );
@@ -106,10 +105,10 @@
       renderer!.update(
-        <HookHarness
-          routeIsOpen={true}
-          onRouteOpen={onRouteOpen}
-          onRouteClose={onRouteClose}
-          onAdapter={(adapter) => {
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
             latestAdapter = adapter;
-          }}
-        />
+          },
+        })
       );
apply_patch(auto_approved=true) exited 0 in 52ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/__tests__/bottom-sheet-adapter.test.ts
file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning import cleanup and test sequencing**
codex
Implementation and tests for the navigation adapter helper are in place; next I’m running `lint`, `typecheck`, and `test` to validate and then I’ll mark `T027` complete if all checks pass.

thinking
**Deciding sequential execution**
exec
/bin/zsh -lc 'yarn lint' in /Users/tolu/Desktop/dev/rn-bottom-sheet exited 1 in 2.91s:

/Users/tolu/Desktop/dev/rn-bottom-sheet/src/navigation/bottom-sheet-adapter.ts
  101:5  error  React Hook useMemo has a missing dependency: 'options'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

✖ 1 problem (1 error, 0 warnings)

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..61acf892be2439482896804e23acbf408d83a4c2
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,108 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const routeIsOpenRef = useRef(options.routeIsOpen);
+  routeIsOpenRef.current = options.routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: options.routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        options.onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          options.onRouteOpen,
+          options.onRouteClose
+        );
+      },
+    }),
+    [
+      options.onOpenChange,
+      options.onRouteClose,
+      options.onRouteOpen,
+      options.routeIsOpen,
+    ]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Fixing lint error on dependencies**
codex
`lint` failed on a hook dependency issue in `useBottomSheetNavigation`; I’m fixing it by destructuring option fields and using stable dependencies so exhaustive-deps passes cleanly.
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/navigation/bottom-sheet-adapter.ts
@@ -83,4 +83,5 @@
 ): BottomSheetNavigationAdapter {
-  const routeIsOpenRef = useRef(options.routeIsOpen);
-  routeIsOpenRef.current = options.routeIsOpen;
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
 
@@ -88,5 +89,5 @@
     () => ({
-      isOpen: options.routeIsOpen,
+      isOpen: routeIsOpen,
       onOpenChange(nextOpen, reason) {
-        options.onOpenChange?.(nextOpen, reason);
+        onOpenChange?.(nextOpen, reason);
         handleRouteSync(
@@ -95,4 +96,4 @@
           routeIsOpenRef.current,
-          options.onRouteOpen,
-          options.onRouteClose
+          onRouteOpen,
+          onRouteClose
         );
@@ -100,8 +101,3 @@
     }),
-    [
-      options.onOpenChange,
-      options.onRouteClose,
-      options.onRouteOpen,
-      options.routeIsOpen,
-    ]
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
   );
apply_patch(auto_approved=true) exited 0 in 58ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/src/navigation/bottom-sheet-adapter.ts
file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Re-running lint and tests**
codex
I’ve patched the dependency issue and am rerunning the full validation set now.
exec
/bin/zsh -lc 'yarn lint' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 2.08s:

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Running typecheck**
exec
/bin/zsh -lc 'yarn typecheck' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.06s:

file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

exec
/bin/zsh -lc 'yarn test' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.16s:
watchman warning:  Recrawled this watch 1 time, most recently because:
MustScanSubDirs UserDroppedTo resolve, please review the information on
https://facebook.github.io/watchman/docs/troubleshooting.html#recrawl
To clear this warning, run:
`watchman watch-del '/Users/tolu/Desktop/dev/rn-bottom-sheet' ; watchman watch-project '/Users/tolu/Desktop/dev/rn-bottom-sheet'`

PASS src/__tests__/bottom-sheet-adapter.test.ts
PASS src/__tests__/bottom-sheet.reanimated.test.ts
PASS example/src/__tests__/sheet-open-dismiss.integration.test.tsx
PASS src/__tests__/bottom-sheet.wrapper.test.ts
PASS src/__tests__/bottom-sheet.navigation.test.ts
PASS src/__tests__/bottom-sheet.methods.test.ts
PASS src/__tests__/bottom-sheet.lifecycle.test.ts
PASS src/__tests__/bottom-sheet.detents.test.ts
PASS src/__tests__/bottom-sheet.contract.test.ts
PASS src/__tests__/index.test.tsx

Test Suites: 10 passed, 10 total
Tests:       19 todo, 32 passed, 51 total
Snapshots:   0 total
file update:
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning task marking updates**
codex
Validation is green (`lint`, `typecheck`, `test` all passed, including the new adapter tests). I’m now updating task tracking files (`specs/.../tasks.md` and `tasks/todo.md`) with completion and verification notes, then I’ll commit and push.

thinking
**Updating task documentation**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/tasks.md
@@ -102,3 +102,3 @@
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/specs/001-native-ios-sheet-bindings/tasks.md
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section

file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning targeted patch update**
exec
/bin/zsh -lc "sed -n '20,140p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "sed -n '260,360p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc "rg -n \"Ralph Iteration 2026-02-12 \\(US3 Navigation Adapter Helper T027\\)|## Review|Findings:\" tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
- [ ] Map detent model and lifecycle events
- [ ] Implement dismissal reason mapping

## Phase 3: Content Hosting

- [ ] Implement arbitrary RN child hosting in presented sheet
- [ ] Add robust attach/detach/recycle cleanup

## Phase 4: Integrations

- [ ] Add optional React Navigation adapter utilities
- [ ] Add Reanimated compatibility surface and docs
- [ ] Add platform fallback behavior for non-iOS

## Phase 5: Verification and Release Readiness

- [x] Add unit tests for API normalization and behavior
- [ ] Add iOS integration tests for presenter/detents/lifecycle
- [ ] Add Maestro happy-path E2E flows in example app
- [x] Add conditional Maestro MCP gate policy (deferred until stable, required at release gate)
 succeeded in 53ms:

 succeeded in 53ms:
58:## Review
62:- Findings:
193:## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Locating relevant code section**
exec
/bin/zsh -lc "sed -n '180,250p' tasks/todo.md" in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 53ms:
- [x] Mark `T025` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
- [x] Capture verification outcomes in the Review section

## Ralph Iteration 2026-02-12 (US3 Reanimated Contract Tests T026)

- [x] Confirm `T026` is the highest-priority truly incomplete item and verify `src/__tests__/bottom-sheet.reanimated.test.ts` does not already exist
- [x] Add reanimated compatibility contract tests in `src/__tests__/bottom-sheet.reanimated.test.ts`
- [x] Implement minimal production changes only if test-driven gaps are found
- [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
- [x] Capture verification outcomes in the Review section

## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)

- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..f0d2fc92d18909f15bc357b1d8729a8821b4f663
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -189,3 +189,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [ ] Capture verification outcomes in the Review section


thinking
**Planning checkbox marking and findings update**
file update
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
@@ -62,2 +62,6 @@
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
@@ -194,7 +198,7 @@
 
-- [ ] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
-- [ ] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
-- [ ] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
-- [ ] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
-- [ ] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
-- [ ] Capture verification outcomes in the Review section
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section
apply_patch(auto_approved=true) exited 0 in 61ms:
Success. Updated the following files:
M /Users/tolu/Desktop/dev/rn-bottom-sheet/tasks/todo.md
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section

file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Planning step status updates**
codex
Task tracking is now updated for `T027`. I’m doing a final diff/status review and then will commit and push the completed iteration.

thinking
**Checking repository status**
exec
/bin/zsh -lc 'git status --short' in /Users/tolu/Desktop/dev/rn-bottom-sheetexec
/bin/zsh -lc 'git diff -- src/navigation/bottom-sheet-adapter.ts src/__tests__/bottom-sheet-adapter.test.ts specs/001-native-ios-sheet-bindings/tasks.md tasks/todo.md' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
 M .specify/templates/plan-template.md
 M .specify/templates/spec-template.md
 M PROMPT_build.md
 M PROMPT_plan.md
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
 M specs/001-native-ios-sheet-bindings/spec.md
 M specs/001-native-ios-sheet-bindings/tasks.md
 M tasks/todo.md
?? logs/
?? src/__tests__/bottom-sheet-adapter.test.ts
?? src/navigation/
?? yarn.lock
 succeeded in 52ms:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98..44f1a14 100644
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8..cced841 100644
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Planning selective staging and commit**
Plan update
  ✓ Write T027 iteration checklist to tasks/todo.md
  ✓ Implement optional navigation adapter helper in src/navigation/bottom-sheet-adapter.ts
  ✓ Add adapter unit tests
  ✓ Mark task completion and run validation commands
  → Document results, commit, and push
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Completing commit step**
exec
/bin/zsh -lc 'git add src/navigation/bottom-sheet-adapter.ts src/__tests__/bottom-sheet-adapter.test.ts specs/001-native-ios-sheet-bindings/tasks.md tasks/todo.md && git commit -m "feat: add navigation adapter helpers for bottom sheet"' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 1.60s:
┃  types ❯ 

[1G[0K⠙[1G[0K[1G[0K⠙[1G[0K
┃  lint ❯ 

[1G[0K⠙[1G[0K[1G[0K⠙[1G[0K
                                      
  ────────────────────────────────────
summary: (done in 1.22 seconds)       
✔️ types (1.20 seconds)
✔️ lint (1.21 seconds)
╭──────────────────────────────────────╮
│ 🥊 lefthook v2.1.1  hook: commit-msg │
╰──────────────────────────────────────╯
┃  commitlint ❯ 

[1G[0K[1G[0K⠙[1G[0K
                                      
  ────────────────────────────────────
summary: (done in 0.35 seconds)       
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Confirming files for push**
codex
The commit is created successfully with the new helper + tests and updated task tracking; I’m pushing this commit to `origin` now.
exec
/bin/zsh -lc 'git push' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 714ms:
To https://github.com/tolulawson/rn-bottom-sheet.git
   98ec803..d7b383e  main -> main
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Verifying clean commit state**
exec
/bin/zsh -lc 'git status --short' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
 M .specify/templates/plan-template.md
 M .specify/templates/spec-template.md
 M PROMPT_build.md
 M PROMPT_plan.md
 M scripts/ralph-loop-codex.sh
 M scripts/ralph-loop.sh
 M specs/001-native-ios-sheet-bindings/spec.md
?? logs/
?? yarn.lock
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Confirming update plan completion**
Plan update
  ✓ Write T027 iteration checklist to tasks/todo.md
  ✓ Implement optional navigation adapter helper in src/navigation/bottom-sheet-adapter.ts
  ✓ Add adapter unit tests
  ✓ Mark task completion and run validation commands
  ✓ Document results, commit, and push
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Deciding iterative task continuation**
exec
/bin/zsh -lc 'git show --stat --oneline d7b383e' in /Users/tolu/Desktop/dev/rn-bottom-sheet succeeded in 52ms:
d7b383e feat: add navigation adapter helpers for bottom sheet
 specs/001-native-ios-sheet-bindings/tasks.md |   2 +-
 src/__tests__/bottom-sheet-adapter.test.ts   | 125 +++++++++++++++++++++++++++
 src/navigation/bottom-sheet-adapter.ts       | 104 ++++++++++++++++++++++
 tasks/todo.md                                |  13 +++
 4 files changed, 243 insertions(+), 1 deletion(-)
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section


thinking
**Planning concise final summary**
codex
Completed one Ralph loop iteration for the highest-priority incomplete spec task: `T027` in `specs/001-native-ios-sheet-bindings/tasks.md`.

- Added navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`:
  - `createBottomSheetNavigationAdapter(...)`
  - `useBottomSheetNavigation(...)`
- Added unit coverage in `src/__tests__/bottom-sheet-adapter.test.ts` for:
  - route-state -> `isOpen` mapping
  - route open/close callback propagation
  - loop-prevention when state is already aligned
- Marked task complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
- Recorded plan + review results in `tasks/todo.md`.

Validation run:
- `yarn lint` passed
- `yarn typecheck` passed
- `yarn test` passed (10 suites, 32 passed tests)

Git:
- Commit: `d7b383e`
- Message: `feat: add navigation adapter helpers for bottom sheet`
- Pushed to `origin/main`

Gate note:
- `E2E Gate State` in `specs/001-native-ios-sheet-bindings/spec.md` is still `deferred`, so Maestro MCP was not a blocking gate this iteration.

I did not output `<promise>DONE</promise>` because there are still incomplete spec tasks (`T028+`).
file update:
diff --git a/specs/001-native-ios-sheet-bindings/tasks.md b/specs/001-native-ios-sheet-bindings/tasks.md
index 9874f98eb88a7602da84cbb06df32a2ee27b5ced..44f1a14a92300a3f9733887e6dcd3dbbb2ad53cb
--- a/specs/001-native-ios-sheet-bindings/tasks.md
+++ b/specs/001-native-ios-sheet-bindings/tasks.md
@@ -100,7 +100,7 @@
 
 ### Implementation for User Story 3
 
-- [ ] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
+- [x] T027 [P] [US3] Create optional navigation adapter helpers in src/navigation/bottom-sheet-adapter.ts
 - [ ] T028 [US3] Export optional navigation adapter entry in src/index.tsx
 - [ ] T029 [US3] Add documented animated wrapper compatibility surface in src/components/BottomSheetNativeView.tsx
 - [ ] T030 [US3] Implement explicit non-iOS fallback behavior and warnings in src/platform/fallback.ts
diff --git a/src/__tests__/bottom-sheet-adapter.test.ts b/src/__tests__/bottom-sheet-adapter.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6c9ab407ccd97e9be1998311c524b3b5a3f0ade
--- /dev/null
+++ b/src/__tests__/bottom-sheet-adapter.test.ts
@@ -0,0 +1,125 @@
+import React, { useEffect } from 'react';
+import TestRenderer from 'react-test-renderer';
+import {
+  createBottomSheetNavigationAdapter,
+  useBottomSheetNavigation,
+  type BottomSheetNavigationAdapter,
+} from '../navigation/bottom-sheet-adapter';
+import type { BottomSheetChangeReason } from '../types/bottom-sheet';
+
+describe('createBottomSheetNavigationAdapter', () => {
+  it('maps route state to controlled isOpen', () => {
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+    });
+
+    expect(adapter.isOpen).toBe(true);
+  });
+
+  it('requests route close when native sheet closes while route is open', () => {
+    const onOpenChange = jest.fn();
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: true,
+      onOpenChange,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'swipe');
+
+    expect(onOpenChange).toHaveBeenCalledWith(false, 'swipe');
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+
+  it('does not request route state changes when sheet state already matches', () => {
+    const onRouteClose = jest.fn();
+    const onRouteOpen = jest.fn();
+    const adapter = createBottomSheetNavigationAdapter({
+      routeIsOpen: false,
+      onRouteClose,
+      onRouteOpen,
+    });
+
+    adapter.onOpenChange(false, 'programmatic');
+
+    expect(onRouteClose).not.toHaveBeenCalled();
+    expect(onRouteOpen).not.toHaveBeenCalled();
+  });
+});
+
+interface HookHarnessProps {
+  routeIsOpen: boolean;
+  onAdapter: (adapter: BottomSheetNavigationAdapter) => void;
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+}
+
+function HookHarness({
+  routeIsOpen,
+  onAdapter,
+  onRouteOpen,
+  onRouteClose,
+}: HookHarnessProps) {
+  const adapter = useBottomSheetNavigation({
+    routeIsOpen,
+    onRouteOpen,
+    onRouteClose,
+  });
+
+  useEffect(() => {
+    onAdapter(adapter);
+  }, [adapter, onAdapter]);
+
+  return null;
+}
+
+describe('useBottomSheetNavigation', () => {
+  it('uses latest route state when handling open changes', () => {
+    const onRouteOpen = jest.fn();
+    const onRouteClose = jest.fn();
+    let latestAdapter: BottomSheetNavigationAdapter | null = null;
+    let renderer: TestRenderer.ReactTestRenderer;
+
+    TestRenderer.act(() => {
+      renderer = TestRenderer.create(
+        React.createElement(HookHarness, {
+          routeIsOpen: false,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+    });
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+
+    TestRenderer.act(() => {
+      renderer!.update(
+        React.createElement(HookHarness, {
+          routeIsOpen: true,
+          onRouteOpen,
+          onRouteClose,
+          onAdapter: (adapter) => {
+            latestAdapter = adapter;
+          },
+        })
+      );
+    });
+
+    TestRenderer.act(() => {
+      latestAdapter?.onOpenChange(true, 'programmatic');
+      latestAdapter?.onOpenChange(false, 'swipe');
+    });
+
+    expect(onRouteOpen).toHaveBeenCalledTimes(1);
+    expect(onRouteClose).toHaveBeenCalledWith('swipe');
+  });
+});
diff --git a/src/navigation/bottom-sheet-adapter.ts b/src/navigation/bottom-sheet-adapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a3b0c9acd36b536c10736191f3c6010379ec280b
--- /dev/null
+++ b/src/navigation/bottom-sheet-adapter.ts
@@ -0,0 +1,104 @@
+import { useMemo, useRef } from 'react';
+import type {
+  BottomSheetChangeReason,
+  OnOpenChangeCallback,
+} from '../types/bottom-sheet';
+
+/**
+ * Configuration for mapping route state to controlled BottomSheet props.
+ */
+export interface BottomSheetNavigationAdapterOptions {
+  /**
+   * Whether the navigation state expects the sheet to be open.
+   */
+  routeIsOpen: boolean;
+  /**
+   * Called when the sheet requests an open transition.
+   */
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Called when the sheet requests a close transition.
+   */
+  onRouteClose?: (reason: BottomSheetChangeReason) => void;
+  /**
+   * Optional side-effect callback for observing open changes.
+   */
+  onOpenChange?: OnOpenChangeCallback;
+}
+
+/**
+ * Controlled BottomSheet props derived from navigation state.
+ */
+export interface BottomSheetNavigationAdapter {
+  isOpen: boolean;
+  onOpenChange: OnOpenChangeCallback;
+}
+
+function handleRouteSync(
+  nextOpen: boolean,
+  reason: BottomSheetChangeReason,
+  routeIsOpen: boolean,
+  onRouteOpen?: (reason: BottomSheetChangeReason) => void,
+  onRouteClose?: (reason: BottomSheetChangeReason) => void
+): void {
+  if (nextOpen === routeIsOpen) {
+    return;
+  }
+
+  if (nextOpen) {
+    onRouteOpen?.(reason);
+    return;
+  }
+
+  onRouteClose?.(reason);
+}
+
+/**
+ * Build controlled BottomSheet props from route state.
+ * Re-create this adapter when route state changes.
+ */
+export function createBottomSheetNavigationAdapter(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  return {
+    isOpen: options.routeIsOpen,
+    onOpenChange(nextOpen, reason) {
+      options.onOpenChange?.(nextOpen, reason);
+      handleRouteSync(
+        nextOpen,
+        reason,
+        options.routeIsOpen,
+        options.onRouteOpen,
+        options.onRouteClose
+      );
+    },
+  };
+}
+
+/**
+ * Hook variant that keeps callback behavior aligned with the latest route state.
+ */
+export function useBottomSheetNavigation(
+  options: BottomSheetNavigationAdapterOptions
+): BottomSheetNavigationAdapter {
+  const { routeIsOpen, onOpenChange, onRouteOpen, onRouteClose } = options;
+  const routeIsOpenRef = useRef(routeIsOpen);
+  routeIsOpenRef.current = routeIsOpen;
+
+  return useMemo(
+    () => ({
+      isOpen: routeIsOpen,
+      onOpenChange(nextOpen, reason) {
+        onOpenChange?.(nextOpen, reason);
+        handleRouteSync(
+          nextOpen,
+          reason,
+          routeIsOpenRef.current,
+          onRouteOpen,
+          onRouteClose
+        );
+      },
+    }),
+    [onOpenChange, onRouteClose, onRouteOpen, routeIsOpen]
+  );
+}
diff --git a/tasks/todo.md b/tasks/todo.md
index b0866f8fa027501388611714e1ddf81033422072..cced8412f8c07fcdcc9014bbaad0c940dfca76c0
--- a/tasks/todo.md
+++ b/tasks/todo.md
@@ -60,6 +60,10 @@
 - Date: 2026-02-12
 - Reviewer: Codex (GPT-5)
 - Findings:
+  - Ralph iteration `T027`: added `src/navigation/bottom-sheet-adapter.ts` with optional navigation sync helpers (`createBottomSheetNavigationAdapter` and `useBottomSheetNavigation`) that map route state to controlled sheet props and avoid circular open/close dispatch when state is already aligned.
+  - Added `src/__tests__/bottom-sheet-adapter.test.ts` to verify route-state mapping, open/close callback propagation, and loop-prevention behavior for matching states.
+  - Marked `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
+  - Re-verified this iteration with passing `yarn lint`, `yarn typecheck`, and `yarn test`.
   - Ralph iteration `T026`: added `src/__tests__/bottom-sheet.reanimated.test.ts` to lock the documented Reanimated compatibility contract for `createAnimatedComponent` wrapping of both `BottomSheet` and `BottomSheetView`, including ref-method continuity and animated prop pass-through behavior.
   - No production-code changes were required for `T026`; the existing wrapper/native export surface already satisfied the contract once coverage was added.
   - Marked `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
@@ -189,3 +193,12 @@
 - [x] Mark `T026` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
 - [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
 - [x] Capture verification outcomes in the Review section
+
+## Ralph Iteration 2026-02-12 (US3 Navigation Adapter Helper T027)
+
+- [x] Confirm `T027` is the highest-priority truly incomplete item and verify `src/navigation/bottom-sheet-adapter.ts` does not already exist
+- [x] Implement optional navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`
+- [x] Add adapter helper unit tests in `src/__tests__/bottom-sheet-adapter.test.ts`
+- [x] Mark `T027` complete in `specs/001-native-ios-sheet-bindings/tasks.md`
+- [x] Run and pass verification: `yarn lint`, `yarn typecheck`, `yarn test`
+- [x] Capture verification outcomes in the Review section

tokens used
96,966
Completed one Ralph loop iteration for the highest-priority incomplete spec task: `T027` in `specs/001-native-ios-sheet-bindings/tasks.md`.

- Added navigation adapter helpers in `src/navigation/bottom-sheet-adapter.ts`:
  - `createBottomSheetNavigationAdapter(...)`
  - `useBottomSheetNavigation(...)`
- Added unit coverage in `src/__tests__/bottom-sheet-adapter.test.ts` for:
  - route-state -> `isOpen` mapping
  - route open/close callback propagation
  - loop-prevention when state is already aligned
- Marked task complete in `specs/001-native-ios-sheet-bindings/tasks.md`.
- Recorded plan + review results in `tasks/todo.md`.

Validation run:
- `yarn lint` passed
- `yarn typecheck` passed
- `yarn test` passed (10 suites, 32 passed tests)

Git:
- Commit: `d7b383e`
- Message: `feat: add navigation adapter helpers for bottom sheet`
- Pushed to `origin/main`

Gate note:
- `E2E Gate State` in `specs/001-native-ios-sheet-bindings/spec.md` is still `deferred`, so Maestro MCP was not a blocking gate this iteration.

I did not output `<promise>DONE</promise>` because there are still incomplete spec tasks (`T028+`).
